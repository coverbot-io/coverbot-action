{"source_files":[{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/budgets/budget/types.ex","source":"defmodule Spendable.Budgets.Budget.Types do\n  use Absinthe.Schema.Notation\n  import Absinthe.Resolution.Helpers, only: [dataloader: 1, dataloader: 3]\n\n  alias Spendable.Budgets.Budget\n  alias Spendable.Budgets.Budget.Resolver\n  alias Spendable.Middleware.CheckAuthentication\n  alias Spendable.Middleware.LoadModel\n\n  object :budget do\n    field :id, :id\n    field :name, :string\n    field :goal, :string\n\n    field :balance, :string do\n      complexity(5)\n\n      resolve(fn budget, _args, _resolution ->\n        {:ok, Budget.balance(budget)}\n      end)\n    end\n\n    field :recent_allocations, list_of(:allocation), resolve: dataloader(Spendable, :allocations, args: %{recent: true})\n    field :allocation_template_lines, list_of(:allocation_template_line), resolve: dataloader(Spendable)\n  end\n\n  object :budget_queries do\n    field :budget, :budget do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: Budget)\n      arg(:id, non_null(:id))\n      resolve(&Resolver.get/2)\n    end\n\n    field :budgets, list_of(:budget) do\n      middleware(CheckAuthentication)\n      resolve(&Resolver.list/2)\n    end\n  end\n\n  object :budget_mutations do\n    field :create_budget, :budget do\n      middleware(CheckAuthentication)\n      arg(:balance, :string)\n      arg(:name, :string)\n      arg(:goal, :string)\n      resolve(&Resolver.create/2)\n    end\n\n    field :update_budget, :budget do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: Budget)\n      arg(:id, non_null(:id))\n      arg(:balance, :string)\n      arg(:name, :string)\n      arg(:goal, :string)\n      resolve(&Resolver.update/2)\n    end\n\n    field :delete_budget, :budget do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: Budget)\n      arg(:id, non_null(:id))\n      resolve(&Resolver.delete/2)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,0,null,null,null],"name":"lib/spendable/application.ex","source":"defmodule Spendable.Application do\n  # See https://hexdocs.pm/elixir/Application.html\n  # for more information on OTP Applications\n  @moduledoc false\n\n  use Application\n  alias Spendable.Web.Endpoint\n\n  def start(_type, _args) do\n    children = [\n      Spendable.Repo,\n      Spendable.Web.Endpoint,\n      %{id: Absinthe.Subscription, start: {Absinthe.Subscription, :start_link, [Spendable.Web.Endpoint]}},\n      Spendable.Broadway.SendNotification,\n      Spendable.Broadway.SyncMember\n    ]\n\n    # See https://hexdocs.pm/elixir/Supervisor.html\n    # for other strategies and supported options\n    opts = [strategy: :one_for_one, name: Spendable.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n\n  # Tell Phoenix to update the endpoint configuration\n  # whenever the application is updated.\n  def config_change(changed, _new, removed) do\n    Endpoint.config_change(changed, removed)\n    :ok\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,43,null,null,2,null,null,1,null,null,null,null,null,null,23,null,null],"name":"lib/spendable.ex","source":"defmodule Spendable do\n  import Ecto.Query, only: [from: 2]\n\n  alias Spendable.Banks.Account\n  alias Spendable.Budgets.Allocation\n\n  def data do\n    Dataloader.Ecto.new(Spendable.Repo, query: &query/2)\n  end\n\n  def query(Account, _args), do: from(Account, order_by: :name)\n\n  def query(Allocation, %{recent: true}) do\n    from(a in Allocation,\n      join: t in assoc(a, :transaction),\n      where: t.date >= ^(Date.utc_today() |> Date.add(-30))\n    )\n  end\n\n  def query(queryable, _args) do\n    queryable\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/budgets/allocation/types.ex","source":"defmodule Spendable.Budgets.Allocation.Types do\n  use Absinthe.Schema.Notation\n  import Absinthe.Resolution.Helpers, only: [dataloader: 1]\n\n  object :allocation do\n    field :id, :id\n    field :amount, :string\n    field :budget, :budget, resolve: dataloader(Spendable)\n    field :transaction, :transaction, resolve: dataloader(Spendable)\n  end\n\n  input_object :allocation_input_object do\n    field :id, :id\n    field :amount, non_null(:string)\n    field :budget_id, non_null(:id)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/auth/types.ex","source":"defmodule Spendable.Auth.Types do\n  use Absinthe.Schema.Notation\n\n  alias Spendable.Auth.Resolver\n\n  object :auth_mutations do\n    field :sign_in_with_apple, type: :user do\n      arg(:token, non_null(:string))\n      resolve(&Resolver.sign_in_with_apple/2)\n    end\n\n    field :login, type: :user do\n      arg(:email, non_null(:string))\n      arg(:password, non_null(:string))\n      resolve(&Resolver.login/2)\n    end\n  end\nend"},{"coverage":[null,null,null,null,8,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null],"name":"lib/spendable/budgets/allocation_template/schema.ex","source":"defmodule Spendable.Budgets.AllocationTemplate do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"budget_allocation_templates\" do\n    field :name, :string\n\n    belongs_to :user, Spendable.User\n\n    has_many :lines, Spendable.Budgets.AllocationTemplateLine,\n      on_replace: :delete,\n      foreign_key: :budget_allocation_template_id\n\n    timestamps()\n  end\n\n  def changeset(model, params \\\\ %{}) do\n    model\n    |> cast(params, __schema__(:fields) -- [:id])\n    |> cast_assoc(:lines)\n    |> validate_required([:user_id, :name])\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/banks/account/types.ex","source":"defmodule Spendable.Banks.Account.Types do\n  use Absinthe.Schema.Notation\n\n  alias Spendable.Banks.Account\n  alias Spendable.Banks.Account.Resolver\n\n  object :bank_account do\n    field :id, :id\n    field :external_id, :string\n    field :name, :string\n    field :number, :string\n    field :sub_type, :string\n    field :sync, :boolean\n    field :type, :string\n\n    field :balance, :string do\n      resolve(fn\n        %{type: \"credit\", balance: balance}, _args, _resolution ->\n          {:ok, Decimal.mult(balance, \"-1\")}\n\n        %{available_balance: nil, balance: balance}, _args, _resolution ->\n          {:ok, balance}\n\n        %{available_balance: available_balance, balance: balance}, _args, _resolution ->\n          if Decimal.eq?(available_balance, \"0\"),\n            do: {:ok, balance},\n            else: {:ok, available_balance}\n      end)\n    end\n  end\n\n  object :bank_account_mutations do\n    field :update_bank_account, :bank_account do\n      middleware(Spendable.Middleware.CheckAuthentication)\n      middleware(Spendable.Middleware.LoadModel, module: Account)\n      arg(:id, non_null(:id))\n      arg(:sync, :boolean)\n      resolve(&Resolver.update/2)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,19,2,17,null,null,null],"name":"lib/middleware/load_model.ex","source":"defmodule Spendable.Middleware.LoadModel do\n  @behaviour Absinthe.Middleware\n\n  alias Absinthe.Resolution\n  alias Spendable.Repo\n\n  def call(%{context: %{current_user: user}, arguments: %{id: id}} = resolution, opts) do\n    case Repo.get_by(opts[:module], id: id, user_id: user.id) do\n      nil -> resolution |> Resolution.put_result({:error, \"not found\"})\n      model -> %{resolution | context: Map.put(resolution.context, :model, model)}\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/budgets/allocation_template_line/factory.ex","source":"defmodule Spendable.Budgets.AllocationTemplateLine.Factory do\n  defmacro __using__(_opts) do\n    quote do\n      def allocation_template_line_factory(attrs) do\n        line = %Spendable.Budgets.AllocationTemplateLine{\n          amount: Spendable.TestUtils.random_decimal(500..100_000),\n          budget: build(:budget, user: attrs[:user])\n        }\n\n        merge_attributes(line, Map.drop(attrs, [:user]))\n      end\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,7,null,null],"name":"lib/spendable/publishers/send_notification_request.ex","source":"defmodule Spendable.Publishers.SendNotificationRequest do\n  @topic if Application.get_env(:spendable, :env) == :prod,\n           do: \"spendable.send-notification-request\",\n           else: \"spendable-dev.send-notification-request\"\n\n  def publish(user_id, title, body) when is_integer(user_id) and is_binary(title) and is_binary(body) do\n    %SendNotificationRequest{user_id: user_id, title: title, body: body}\n    |> SendNotificationRequest.encode()\n    |> Weddell.publish(@topic)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/notification_settings/factory.ex","source":"defmodule Spendable.Notifications.Settings.Factory do\n  defmacro __using__(_opts) do\n    quote do\n      def notification_settings_factory do\n        %Spendable.Notifications.Settings{\n          device_token: \"test-device-token\",\n          provider: :apns\n        }\n      end\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,null,null,1,null,1,null,null,1,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,1,null,null],"name":"lib/spendable/user/utils.ex","source":"defmodule Spendable.User.Utils do\n  import Ecto.Query, only: [from: 2, subquery: 1]\n\n  alias Spendable.Banks.Account\n  alias Spendable.Budgets.Allocation\n  alias Spendable.Budgets.Budget\n  alias Spendable.Repo\n\n  def calculate_spendable(user) do\n    balance =\n      from(ba in Account,\n        select:\n          fragment(\n            \"SUM(CASE WHEN ? = 'credit' THEN -? ELSE COALESCE(?, ?) END)\",\n            ba.type,\n            ba.balance,\n            ba.available_balance,\n            ba.balance\n          ),\n        where: ba.user_id == ^user.id and ba.sync\n      )\n      |> Repo.one()\n      |> Kernel.||(\"0.00\")\n\n    allocations_query =\n      from(a in Allocation,\n        join: b in assoc(a, :budget),\n        where: b.user_id == ^user.id,\n        select: %{\n          budget_id: b.id,\n          allocated: sum(a.amount)\n        },\n        group_by: b.id\n      )\n\n    allocated =\n      from(a in subquery(allocations_query),\n        join: b in Budget,\n        on: a.budget_id == b.id,\n        select: fragment(\"SUM(ABS(? + ?))\", a.allocated, b.adjustment)\n      )\n      |> Repo.one()\n\n    Decimal.sub(balance, allocated)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null],"name":"test/factory.ex","source":"defmodule Spendable.Factory do\n  use ExMachina.Ecto, repo: Spendable.Repo\n  use Spendable.Banks.Account.Factory\n  use Spendable.Banks.Member.Factory\n  use Spendable.Budgets.Allocation.Factory\n  use Spendable.Budgets.AllocationTemplate.Factory\n  use Spendable.Budgets.AllocationTemplateLine.Factory\n  use Spendable.Budgets.Budget.Factory\n  use Spendable.Notifications.Settings.Factory\n  use Spendable.Tag.Factory\n  use Spendable.Transaction.Factory\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,3,null,3,2,null,null,null,null,null],"name":"test/support/data_case.ex","source":"defmodule Spendable.DataCase do\n  @moduledoc \"\"\"\n  This module defines the setup for tests requiring\n  access to the application's data layer.\n\n  You may define functions here to be used as helpers in\n  your tests.\n\n  Finally, if the test case interacts with the database,\n  it cannot be async. For this reason, every test runs\n  inside a transaction which is reset at the beginning\n  of the test unless the test case is marked as async.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  alias Ecto.Adapters.SQL.Sandbox\n\n  using do\n    quote do\n      alias Spendable.Repo\n\n      import Ecto\n      import Ecto.Changeset\n      import Ecto.Query\n      import Spendable.DataCase\n    end\n  end\n\n  setup tags do\n    :ok = Sandbox.checkout(Spendable.Repo)\n\n    unless tags[:async] do\n      Sandbox.mode(Spendable.Repo, {:shared, self()})\n    end\n\n    :ok\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,1,null,1,1,null,null,0,null,null,null],"name":"lib/spendable/banks/account/resolver.ex","source":"defmodule Spendable.Banks.Account.Resolver do\n  alias Spendable.Banks.Account\n  alias Spendable.Publishers.SyncMemberRequest\n  alias Spendable.Repo\n\n  def update(params, %{context: %{model: model}}) do\n    model\n    |> Account.changeset(params)\n    |> Repo.update()\n    |> case do\n      {:ok, %{sync: true} = model} = response ->\n        :ok = SyncMemberRequest.publish(model.bank_member_id)\n        response\n\n      response ->\n        response\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null],"name":"lib/spendable_web.ex","source":"defmodule Spendable.Web do\n  @moduledoc \"\"\"\n  The entrypoint for defining your web interface, such\n  as controllers, views, channels and so on.\n\n  This can be used in your application as:\n\n      use Spendable.Web, :controller\n      use Spendable.Web, :view\n\n  The definitions below will be executed for every view,\n  controller, etc, so keep them short and clean, focused\n  on imports, uses and aliases.\n\n  Do NOT define functions inside the quoted expressions\n  below. Instead, define any helper function in modules\n  and import those modules here.\n  \"\"\"\n\n  def controller do\n    quote do\n      use Phoenix.Controller, namespace: Spendable.Web\n\n      import Plug.Conn\n      import Spendable.Web.Gettext\n      alias Spendable.Web.Router.Helpers, as: Routes\n    end\n  end\n\n  def view do\n    quote do\n      use Phoenix.View,\n        root: \"lib/spendable_web/templates\",\n        namespace: Spendable.Web\n\n      # Import convenience functions from controllers\n      import Phoenix.Controller, only: [get_flash: 1, get_flash: 2, view_module: 1]\n\n      # Use all HTML functionality (forms, tags, etc)\n      use Phoenix.HTML\n\n      import Spendable.Web.Gettext\n      alias Spendable.Web.Router.Helpers, as: Routes\n    end\n  end\n\n  def router do\n    quote do\n      use Phoenix.Router\n      use Plug.ErrorHandler\n      use Sentry.Plug\n      import Plug.Conn\n      import Phoenix.Controller\n    end\n  end\n\n  def channel do\n    quote do\n      use Phoenix.Channel\n      import Spendable.Web.Gettext\n    end\n  end\n\n  @doc \"\"\"\n  When used, dispatch to the appropriate controller/view/etc.\n  \"\"\"\n  defmacro __using__(which) when is_atom(which) do\n    apply(__MODULE__, which, [])\n  end\nend"},{"coverage":[null,null,null,null,29,null,null,null,null,1,1,null,null,null,null],"name":"lib/middleware/changeset_errors.ex","source":"defmodule Spendable.Middleware.ChangesetErrors do\n  @behaviour Absinthe.Middleware\n\n  def call(resolution, _config) do\n    %{resolution | errors: Enum.flat_map(resolution.errors, &handle_error/1)}\n  end\n\n  defp handle_error(%Ecto.Changeset{} = changeset) do\n    changeset\n    |> Ecto.Changeset.traverse_errors(fn {err, _opts} -> err end)\n    |> Enum.map(fn {k, v} -> \"#{k}: #{v}\" end)\n  end\n\n  defp handle_error(error), do: [error]\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,43,null,null,null,43,null,null,null,124,null,null,null,null,null,0,null,null,null,49,null,null,41,null,41,null,null],"name":"lib/spendable_web/schema.ex","source":"defmodule Spendable.Web.Schema do\n  use Absinthe.Schema\n\n  import_types(Spendable.Auth.Types)\n  import_types(Spendable.Banks.Account.Types)\n  import_types(Spendable.Banks.Category.Types)\n  import_types(Spendable.Banks.Member.Types)\n  import_types(Spendable.Banks.Transaction.Types)\n  import_types(Spendable.Budgets.Allocation.Types)\n  import_types(Spendable.Budgets.AllocationTemplate.Types)\n  import_types(Spendable.Budgets.AllocationTemplateLine.Types)\n  import_types(Spendable.Budgets.Budget.Types)\n  import_types(Spendable.Notifications.Settings.Types)\n  import_types(Spendable.Tag.Types)\n  import_types(Spendable.Transaction.Types)\n  import_types(Spendable.User.Types)\n\n  query do\n    field :health, :string, resolve: fn _args, _resolution -> {:ok, \"up\"} end\n    import_fields(:allocation_template_queries)\n    import_fields(:bank_member_queries)\n    import_fields(:budget_queries)\n    import_fields(:category_queries)\n    import_fields(:notification_settings_queries)\n    import_fields(:tag_queries)\n    import_fields(:transaction_queries)\n    import_fields(:user_queries)\n  end\n\n  mutation do\n    import_fields(:allocation_template_mutations)\n    import_fields(:auth_mutations)\n    import_fields(:bank_account_mutations)\n    import_fields(:bank_member_mutations)\n    import_fields(:budget_mutations)\n    import_fields(:notification_settings_mutations)\n    import_fields(:tag_mutations)\n    import_fields(:transaction_mutations)\n    import_fields(:user_mutations)\n  end\n\n  def context(context) do\n    loader =\n      Dataloader.new()\n      |> Dataloader.add_source(Spendable, Spendable.data())\n\n    Map.put(context, :loader, loader)\n  end\n\n  def plugins do\n    [Absinthe.Middleware.Dataloader] ++ Absinthe.Plugin.defaults()\n  end\n\n  def middleware(middleware, _field, %{identifier: :mutation}) do\n    # this middleware needs to append to the end\n    # credo:disable-for-next-line Credo.Check.Refactor.AppendSingleItem\n    middleware ++ [Spendable.Middleware.ChangesetErrors]\n  end\n\n  # if it's any other object keep things as is\n  def middleware(middleware, _field, _object), do: middleware\n\n  def pipeline(config, pipeline_opts) do\n    config.schema_mod\n    |> Absinthe.Pipeline.for_document(pipeline_opts)\n    |> Absinthe.Pipeline.insert_after(Absinthe.Phase.Document.Complexity.Analysis, Spendable.Web.Utils.LogComplexity)\n  end\nend"},{"coverage":[null,null,null,null,15,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8,null,null],"name":"lib/spendable/banks/member/schema.ex","source":"defmodule Spendable.Banks.Member do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"bank_members\" do\n    field :external_id, :string\n    field :institution_id, :string\n    field :logo, :string\n    field :name, :string\n    field :plaid_token, :string\n    field :provider, :string\n    field :status, :string\n\n    belongs_to :user, Spendable.User\n    has_many :bank_accounts, Spendable.Banks.Account, foreign_key: :bank_member_id\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(model, attrs) do\n    model\n    |> cast(attrs, [:external_id, :institution_id, :logo, :name, :plaid_token, :provider, :status, :user_id])\n    |> validate_required([:name, :user_id, :external_id, :provider])\n  end\nend"},{"coverage":[null,null,null,null,null,40,null,null,null,null,40,null,null,null,null,null,null],"name":"lib/spendable_web/utils/log_complexity.ex","source":"defmodule Spendable.Web.Utils.LogComplexity do\n  use Absinthe.Phase\n  require Logger\n\n  def run(input, _options \\\\ []) do\n    {_operation, complexity} =\n      input\n      |> Absinthe.Blueprint.current_operation()\n      |> Absinthe.Blueprint.prewalk(0, &handle_node/2)\n\n    Logger.info(\"Query complexity: #{inspect(complexity)}\")\n    {:ok, input}\n  end\n\n  def handle_node(%{complexity: complexity} = node, max) when complexity > max, do: {node, complexity}\n  def handle_node(node, max), do: {node, max}\nend"},{"coverage":[null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"test/support/test_data/sync_member.ex","source":"defmodule Spendable.Broadway.SyncMemberTest.TestData do\n  def item do\n    %{\n      item: %{\n        available_products: [\n          \"assets\",\n          \"auth\",\n          \"balance\",\n          \"credit_details\",\n          \"identity\",\n          \"income\",\n          \"investments\",\n          \"liabilities\"\n        ],\n        billed_products: [\n          \"transactions\"\n        ],\n        error: nil,\n        institution_id: \"ins_109511\",\n        item_id: \"jQ3ZbE3BWqUMeqNBgDK6fjdyErroNwu1EPKnL\",\n        webhook: \"\"\n      },\n      request_id: \"fkUsuVz2DGXZ75e\",\n      status: %{\n        last_webhook: nil,\n        transactions: %{\n          last_failed_update: nil,\n          last_successful_update: \"2019-10-10T04:55:55.554Z\"\n        }\n      }\n    }\n  end\n\n  def institution do\n    %{\n      institution: %{\n        country_codes: [\n          \"US\"\n        ],\n        credentials: [\n          %{\n            label: \"Username\",\n            name: \"username\",\n            type: \"text\"\n          },\n          %{\n            label: \"Password\",\n            name: \"password\",\n            type: \"password\"\n          }\n        ],\n        has_mfa: true,\n        input_spec: \"fixed\",\n        institution_id: \"ins_109511\",\n        logo:\n          \"iVBORw0KGgoAAAANSUhEUgAAAJgAAACYCAMAAAAvHNATAAAAVFBMVEVHcEz///////////////////////////////////////////////8XT3z+/v4YUoAmW4Y1Zo7g6O28zNmovM3Q2+RFcpfx9Pdsj6yTrcF/nrdYgaHWRlIqAAAADXRSTlMAoIFJv9Cq5CESlmkzSnBKmwAACR5JREFUeNrNnNmW4joMRRsIM8QZyfT//3kphmBLR7IoQt34qXtVgB3Htnbk4d+/D8v+tFouNkmy3m7TdLtdJ8lmsVyd9v/+x7I7HpIrDS7b5HDc/S9QC5HJo1v8LdzqYIAa4Q6rP6qr5RtUD7bl1+ttf1ynvyrr4ze7w+6QflAO36q23SL9sCy+gXbapBOUzWnq2poE64Y2aa0d0+nK9jjdU1ynk5b1NM9zv0gnL4sJxo7VNv1C2X4cDZbpl8rys86YpF8ryW5uj/Hzx7lMv1x++TgP6dfL4Tdcm/QPyub90StJ/6Qkb45o+3X6R2X9Ftne2B2bcqjwX8qhbIydcz9xfTV1N+Rnl5WQK3PnbOjqZto6i7evumpz59z5WhDZD9f55+95W8Xhkon6Y1H1lwfUrbgScj3+6NylrYpJ+qY2fhVlf8l8qtuPVyLXgy279GXx6Xi2lFt6N2RnAnX75axSuEa4oZP7gyEGrLSWzn/xXnwyxPWgO+dif4jGzd1WbelSeT3NMlOvk/rDdvdmh6QtPUZWZfFLYX9I3mtgXSZTXf/gKJnH5Zz2UZf17zQz1sAuToT6GT/r3AVklfffvFbbpcsbezNjkahwwu0O/b2HFT55FXKNPRnXnKvtsYm9D1WOQ7lgTArIXo/2wSWPfddLOvbuJL4/sr7S0pEyZ622QE/b5fSqqqV9yA3s56T3TRa6mzwYrHDcA2SM6znqBF02Y1+2tuYB6uAns1oIU4zsIoSfOrjRM4/+MHuw41/Uhb+IDedasSGZk7nC63p+yd7mFAMJ1iKZf6GV63qhyTNO4PcyFq0Fst7pFXHjYjE0A3dwslRYCTwCknXRRwRju6sMVbaL1INGRpoiJIMu1IIf3cXGVj8edbnmq5yfk/lOmz1vhEclPsqiChvjUZbSmKjVFyILuMo0l6ISrzKk08949DNEe2TEV7368kf2XuEaAwqPSlSz96i5Bh/368wn87kGb9Tw24/nju42Svu3rI9lKPnbPFHuFY6fZsDV+LH1ReY77T22F9kTE3n2UYuSfjx6NFH/aT7JCFfaADLfHZ/OMXYrNPqs9aY/Nurx1gtWZ5SLkjUC1/hBPOTt9De2Z4N5PTdK1jIuTsbd0R+6UVTyJRulUMZ4lGErdB2rHOZwrsVc8Ms9lVVfJeFNBWSYi9ol4kKPA9n/QYvLYTPAvto2sVBGuHgDhkMZTIY9CUgIQr7aNvEgRZyWdnn4LGGfFIcaRoZumpIx127UqPTol3BqTR6cCRl+GH3MadWo9BhjF9F4pJl0b1BH4LR6VFrIg4VS1aFIC2BdANaITeWciY0MNrFaVqZmMPgqcVpApkalWyM7qvGoj3BhMua0/GHqUekojWKD1MQYF/rqnmcWGNnYyC7SSJZo8egcWiHi4mRwgCVkLxeCUSkR2n6JrTAtBoOvYqcNyXynrXDr38feTb0PBqGyb7GvBi7UYTLmtEBjT7G35tEKw6G1g1bIHM3vBiMZd1rw4rsSMiWcjHBhX2XuWPE6KzMptvuCIaX1ma+GMpZiX+VOG6piQfLHEtdVFsVVFYQMcPE6Q05LyQR3ZEFJnjgKmzriIlbYCk4boHQmrnSjzbQFZFLy1CeTnLbC1yhc14FMmwLEvlppeVrsjmhaQuW6gqlzpshXK0NShTkaJ8N5Wu/lUp9kpmQOjdO9wWnZFNNFn8PcRsCYr1YGX21x4s6Up32BRae+Ly7GRXy1Fabvnfk5/pQoWJACx4ZOnHZook57Vhv+HWwb44r7KnXaCyLrzqbUvLWN0RQ4IuNOCxpQZ02Aj2DqcFFncV/l7gh8ledDI2RrdYCF09uEDDstIYN5WpVMHfmlafdecFqRrMffo5ElShAPU7rYV5sgtgu+GrhQqabmvSC+sHH5huNeSUbijtBXiaNJaWaqPUsbF/RV7mjMCoE7msiWkloHXDX2VeSOjAw4rYVsJbyMQC0ndQadlpJBp9UmWsaXkX0s4vrRI/gZwWkDssHBUBW86pTCLAQa+mtJ51r8MtsJSw/EPK1PVgrpnkTLQrFo2xqctjI4bXE5a3moREqqyHm73uC0wFdZnlbP3B2imc425qvQaSmZ8jVyrhPnhpWsci8uHRN9FbhjOIUGs8NqNv1cp/r6FWEcCt7YhvgUGsqnL9T5hy6yrAP7atP61+TlO21lTA4fVUMfYk6LfJU6LfcIfc7mGJ+AYAk/7rTcV7nTUrJXVrxQJga3WhaWZJW503JfRXlaQqbPC261SS6ct8ZOG5Jhpw3JOjVnfdCmBcducxG4pKmPwGmd4KuDmuVfqROpYG4kdDTsq6HT1thXDfMi8tRz6/gS19Adka9Sp8XuVarxaKlP1rORhjktyK9yR4Nk+tzbTl/eQKMSSoFTX2X5YyEBrsWVYEHgUcum3BsZTjWHZNhpOZkej46xJTRBVJJSzQFZjt2Rpeb1eLSPLTryW6icahbyq52Wmlfj0SG+TOvVp7UUeGVwWkKmxqNdfGHbOAq2aqoZ+GqlJiZbbUZwYVgKOI5TkRQ4IYNOi1LzMB7tDIsna2dMgYe+ip0WJcBLlLOwLDfNrSnwzjB9z8lQPDqZFui2LpopBE6bl8bU/GCpMDiWkQ5nXaqc2chAPMI7R2KLwHPjUmWFLFd3GgiLwFHEDG8Rb8lCeVpEdlvSH9yoddk8aP99fEsWdlpChjZBgHh0Mm/NKJ22YYRyZf6/RzJp2wgf7RZvbGbJlC02DXM05qvaBjAWj7SNlisxKvGK+9mSVRF3DDNy6gYwHo9W72yYqrRtXMFexvuzC3qo+slLJQq1bc+nYeOb77Rs7LBuf0t+sSkvslUwXG6ikjlxA210U56UxRY3VzKnlchof36jgcU2+gtbsqhzFDna+KlvSl1+ulUWbWtkLkTI4AYwTad/u7m4uQYXr8kBR3tFa9vGZ/PG//h27Fd/gO54I3PWreLm7djGDf/3WIOd9kqmtHQSut/ZWm89gaOQGnRRFsav2L53GMFMD0mY77ES8z2IY8ZHl8z3sJf5Ho8z3wOF5nsE04wPrZrvMV/zPRht6qPk0umOkpvx4XvzPa5wxgc8zvhIzBkfIjrjY1fnfFDtnI/2HeFmeBjyqzt86fjo/wCvNvR/+ZR1KwAAAABJRU5ErkJggg==\",\n        mfa: [\n          \"code\",\n          \"list\",\n          \"questions\",\n          \"selections\"\n        ],\n        mfa_code_type: \"numeric\",\n        name: \"Tartan Bank\",\n        primary_color: \"#174e7c\",\n        products: [\n          \"assets\",\n          \"auth\",\n          \"balance\",\n          \"transactions\",\n          \"credit_details\",\n          \"income\",\n          \"identity\",\n          \"investments\",\n          \"liabilities\"\n        ],\n        routing_numbers: [],\n        url: \"https://www.plaid.com/\"\n      },\n      request_id: \"njyA6jBhKz4a4Lf\"\n    }\n  end\n\n  def accounts do\n    %{\n      accounts: [\n        %{\n          account_id: \"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\",\n          balances: %{\n            available: 100,\n            current: 110,\n            iso_currency_code: \"USD\",\n            limit: nil,\n            unofficial_currency_code: nil\n          },\n          mask: \"0000\",\n          name: \"Plaid Checking\",\n          official_name: \"Plaid Gold Standard 0% Interest Checking\",\n          subtype: \"checking\",\n          type: \"depository\"\n        },\n        %{\n          account_id: \"BeNlRPNEjncZMa1BGy3RtgzBPEznjqfwjeoW3\",\n          balances: %{\n            available: 200,\n            current: 210,\n            iso_currency_code: \"USD\",\n            limit: nil,\n            unofficial_currency_code: nil\n          },\n          mask: \"1111\",\n          name: \"Plaid Saving\",\n          official_name: \"Plaid Silver Standard 0.1% Interest Saving\",\n          subtype: \"savings\",\n          type: \"depository\"\n        },\n        %{\n          account_id: \"RmJV83JvKNhVNJeq7AgDcPe5NReLqJfR4dVlD\",\n          balances: %{\n            available: nil,\n            current: 1000,\n            iso_currency_code: \"USD\",\n            limit: nil,\n            unofficial_currency_code: nil\n          },\n          mask: \"2222\",\n          name: \"Plaid CD\",\n          official_name: \"Plaid Bronze Standard 0.2% Interest CD\",\n          subtype: \"cd\",\n          type: \"depository\"\n        },\n        %{\n          account_id: \"6rJmglJjqZiJ65RDpQN4SK9bWg9rR8Hg3w794\",\n          balances: %{\n            available: nil,\n            current: 410,\n            iso_currency_code: \"USD\",\n            limit: 2000,\n            unofficial_currency_code: nil\n          },\n          mask: \"3333\",\n          name: \"Plaid Credit Card\",\n          official_name: \"Plaid Diamond 12.5% APR Interest Credit Card\",\n          subtype: \"credit card\",\n          type: \"credit\"\n        },\n        %{\n          account_id: \"XXp18PpvdZfQZBPxLMywt1G68ZG7XBcdEBA63\",\n          balances: %{\n            available: 43200,\n            current: 43200,\n            iso_currency_code: \"USD\",\n            limit: nil,\n            unofficial_currency_code: nil\n          },\n          mask: \"4444\",\n          name: \"Plaid Money Market\",\n          official_name: \"Plaid Platinum Standard 1.85% Interest Money Market\",\n          subtype: \"money market\",\n          type: \"depository\"\n        },\n        %{\n          account_id: \"DZKR87KAemCdeN7JlKy1Uo5vgG5qPNFvQyqwB\",\n          balances: %{\n            available: nil,\n            current: 320.76,\n            iso_currency_code: \"USD\",\n            limit: nil,\n            unofficial_currency_code: nil\n          },\n          mask: \"5555\",\n          name: \"Plaid IRA\",\n          official_name: nil,\n          subtype: \"ira\",\n          type: \"investment\"\n        },\n        %{\n          account_id: \"VRo1W4ov3euaeX68MDEBtqDXQlDyVBtWd7Mme\",\n          balances: %{\n            available: nil,\n            current: 23631.9805,\n            iso_currency_code: \"USD\",\n            limit: nil,\n            unofficial_currency_code: nil\n          },\n          mask: \"6666\",\n          name: \"Plaid 401k\",\n          official_name: nil,\n          subtype: \"401k\",\n          type: \"investment\"\n        },\n        %{\n          account_id: \"wnDAKEDMP7FR17bAl5NzUawK4gwRJjirVeXNo\",\n          balances: %{\n            available: nil,\n            current: 65262,\n            iso_currency_code: \"USD\",\n            limit: nil,\n            unofficial_currency_code: nil\n          },\n          mask: \"7777\",\n          name: \"Plaid Student Loan\",\n          official_name: nil,\n          subtype: \"student\",\n          type: \"loan\"\n        }\n      ],\n      item: %{\n        available_products: [\n          \"assets\",\n          \"auth\",\n          \"balance\",\n          \"credit_details\",\n          \"identity\",\n          \"income\",\n          \"investments\",\n          \"liabilities\"\n        ],\n        billed_products: [\n          \"transactions\"\n        ],\n        error: nil,\n        institution_id: \"ins_109511\",\n        item_id: \"jQ3ZbE3BWqUMeqNBgDK6fjdyErroNwu1EPKnL\",\n        webhook: \"\"\n      },\n      request_id: \"YRZvS0XA4qOSjCC\"\n    }\n  end\n\n  def account_transactions(\"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\") do\n    %{\n      accounts: [\n        %{\n          account_id: \"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\",\n          balances: %{\n            available: 100,\n            current: 110,\n            iso_currency_code: \"USD\",\n            limit: nil,\n            unofficial_currency_code: nil\n          },\n          mask: \"0000\",\n          name: \"Plaid Checking\",\n          official_name: \"Plaid Gold Standard 0% Interest Checking\",\n          subtype: \"checking\",\n          type: \"depository\"\n        }\n      ],\n      item: %{\n        available_products: [\n          \"assets\",\n          \"auth\",\n          \"balance\",\n          \"credit_details\",\n          \"identity\",\n          \"income\",\n          \"investments\",\n          \"liabilities\"\n        ],\n        billed_products: [\n          \"transactions\"\n        ],\n        error: nil,\n        institution_id: \"ins_109511\",\n        item_id: \"jQ3ZbE3BWqUMeqNBgDK6fjdyErroNwu1EPKnL\",\n        webhook: \"\"\n      },\n      request_id: \"g46u5D13O5yCPJ3\",\n      total_transactions: 7,\n      transactions: [\n        %{\n          account_id: \"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\",\n          account_owner: nil,\n          amount: 6.33,\n          category: [\n            \"Travel\",\n            \"Car Service\",\n            \"Ride Share\"\n          ],\n          category_id: \"22006001\",\n          date: \"#{Date.utc_today()}\",\n          iso_currency_code: \"USD\",\n          name: \"Uber 072515 SF**POOL**\",\n          payment_meta: %{\n            by_order_of: nil,\n            payee: nil,\n            payer: nil,\n            payment_method: nil,\n            payment_processor: nil,\n            ppd_id: nil,\n            reason: nil,\n            reference_number: nil\n          },\n          pending: false,\n          pending_transaction_id: nil,\n          transaction_id: \"gjwAb9wKgytqA9dKR4Xmc3rwN8WN5nigoEkrB\",\n          transaction_type: \"special\",\n          unofficial_currency_code: nil\n        },\n        %{\n          account_id: \"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\",\n          account_owner: nil,\n          amount: 5.4,\n          category: [\n            \"Travel\",\n            \"Car Service\",\n            \"Ride Share\"\n          ],\n          category_id: \"22006001\",\n          date: \"2019-09-18\",\n          iso_currency_code: \"USD\",\n          name: \"Uber 063015 SF**POOL**\",\n          payment_meta: %{\n            by_order_of: nil,\n            payee: nil,\n            payer: nil,\n            payment_method: nil,\n            payment_processor: nil,\n            ppd_id: nil,\n            reason: nil,\n            reference_number: nil\n          },\n          pending: true,\n          pending_transaction_id: nil,\n          transaction_id: \"8B4wpK4er1FV9XMAWGxEc81aP5MPzncwnWEzA\",\n          transaction_type: \"special\",\n          unofficial_currency_code: nil\n        },\n        %{\n          account_id: \"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\",\n          account_owner: nil,\n          amount: 5.4,\n          category: [\n            \"Travel\",\n            \"Car Service\",\n            \"Ride Share\"\n          ],\n          category_id: \"22006001\",\n          date: \"2019-09-18\",\n          iso_currency_code: \"USD\",\n          name: \"Uber 063015 SF**POOL**\",\n          payment_meta: %{\n            by_order_of: nil,\n            payee: nil,\n            payer: nil,\n            payment_method: nil,\n            payment_processor: nil,\n            ppd_id: nil,\n            reason: nil,\n            reference_number: nil\n          },\n          pending: false,\n          pending_transaction_id: \"8B4wpK4er1FV9XMAWGxEc81aP5MPzncwnWEzA\",\n          transaction_id: \"8B4wpK4er1FV9XMAWGxEc81aP5MPzncwnWEzB\",\n          transaction_type: \"special\",\n          unofficial_currency_code: nil\n        },\n        %{\n          account_id: \"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\",\n          account_owner: nil,\n          amount: -500,\n          category: [\n            \"Travel\",\n            \"Airlines and Aviation Services\"\n          ],\n          category_id: \"22001000\",\n          date: \"2019-09-16\",\n          iso_currency_code: \"USD\",\n          name: \"United Airlines\",\n          payment_meta: %{\n            by_order_of: nil,\n            payee: nil,\n            payer: nil,\n            payment_method: nil,\n            payment_processor: nil,\n            ppd_id: nil,\n            reason: nil,\n            reference_number: nil\n          },\n          pending: false,\n          pending_transaction_id: nil,\n          transaction_id: \"EMRN9eRGQySgAPL8qNWvClGXDvkDoWuXy4dVM\",\n          transaction_type: \"special\",\n          unofficial_currency_code: nil\n        },\n        %{\n          account_id: \"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\",\n          account_owner: nil,\n          amount: 12,\n          category: [\n            \"Food and Drink\",\n            \"Restaurants\"\n          ],\n          category_id: \"13005000\",\n          date: \"2019-09-15\",\n          iso_currency_code: \"USD\",\n          location: %{\n            address: nil,\n            city: nil,\n            country: nil,\n            lat: nil,\n            lon: nil,\n            postal_code: nil,\n            region: nil,\n            store_number: \"3322\"\n          },\n          name: \"McDonald's\",\n          payment_meta: %{\n            by_order_of: nil,\n            payee: nil,\n            payer: nil,\n            payment_method: nil,\n            payment_processor: nil,\n            ppd_id: nil,\n            reason: nil,\n            reference_number: nil\n          },\n          pending: false,\n          pending_transaction_id: nil,\n          transaction_id: \"W6w8RNwvxQfzQLbW1Aj7fPoRvznv8GulR6avN\",\n          transaction_type: \"place\",\n          unofficial_currency_code: nil\n        },\n        %{\n          account_id: \"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\",\n          account_owner: nil,\n          amount: 4.33,\n          category: [\n            \"Food and Drink\",\n            \"Restaurants\",\n            \"Coffee Shop\"\n          ],\n          category_id: \"13005043\",\n          date: \"2019-09-15\",\n          iso_currency_code: \"USD\",\n          name: \"Starbucks\",\n          payment_meta: %{\n            by_order_of: nil,\n            payee: nil,\n            payer: nil,\n            payment_method: nil,\n            payment_processor: nil,\n            ppd_id: nil,\n            reason: nil,\n            reference_number: nil\n          },\n          pending: false,\n          pending_transaction_id: nil,\n          transaction_id: \"A75QnN58PGFwJdmez7obtXjM3br3DWC189eyR\",\n          transaction_type: \"place\",\n          unofficial_currency_code: nil\n        },\n        %{\n          account_id: \"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\",\n          account_owner: nil,\n          amount: 89.4,\n          category: [\n            \"Food and Drink\",\n            \"Restaurants\"\n          ],\n          category_id: \"13005000\",\n          date: \"2019-09-14\",\n          iso_currency_code: \"USD\",\n          name: \"SparkFun\",\n          payment_meta: %{\n            by_order_of: nil,\n            payee: nil,\n            payer: nil,\n            payment_method: nil,\n            payment_processor: nil,\n            ppd_id: nil,\n            reason: nil,\n            reference_number: nil\n          },\n          pending: false,\n          pending_transaction_id: nil,\n          transaction_id: \"GLb3QZbvMli6l78ErQDwFGe9JW7J4AI1a6j8W\",\n          transaction_type: \"place\",\n          unofficial_currency_code: nil\n        },\n        %{\n          account_id: \"zyBMmKBpeZcDVZgqEx3ACKveJjvwmBHomPbyP\",\n          account_owner: nil,\n          amount: 6.33,\n          category: [\n            \"Travel\",\n            \"Car Service\",\n            \"Ride Share\"\n          ],\n          category_id: \"22006001\",\n          date: \"2019-09-01\",\n          iso_currency_code: \"USD\",\n          name: \"Uber 072515 SF**POOL**\",\n          payment_meta: %{\n            by_order_of: nil,\n            payee: nil,\n            payer: nil,\n            payment_method: nil,\n            payment_processor: nil,\n            ppd_id: nil,\n            reason: nil,\n            reference_number: nil\n          },\n          pending: false,\n          pending_transaction_id: nil,\n          transaction_id: \"1XrylZrdRkfgLDvwaXbVC6KpA9WEWaF5oWdme\",\n          transaction_type: \"special\",\n          unofficial_currency_code: nil\n        }\n      ]\n    }\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,2,null,1,null,null,1,null,1,null,null,null,1,null],"name":"lib/spendable_web/controllers/plaid/controller.ex","source":"defmodule Spendable.Web.Controllers.Plaid do\n  use Spendable.Web, :controller\n\n  alias Spendable.Publishers.SyncMemberRequest\n  alias Spendable.Repo\n\n  def webhook(conn, %{\"item_id\" => item_id}) when is_binary(item_id) do\n    case Repo.get_by(Spendable.Banks.Member, external_id: item_id) do\n      nil ->\n        send_resp(conn, :not_found, \"\")\n\n      member ->\n        :ok = SyncMemberRequest.publish(member.id)\n\n        send_resp(conn, :ok, \"\")\n    end\n  end\n\n  def webhook(conn, _params), do: send_resp(conn, :not_found, \"\")\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2987,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"deps/absinthe/lib/absinthe/phase/schema/compile.ex","source":"defmodule Absinthe.Phase.Schema.Compile do\n  @moduledoc false\n\n  alias Absinthe.Blueprint.Schema\n\n  def run(blueprint, opts) do\n    module_name = Module.concat(opts[:schema], Compiled)\n\n    %{schema_definitions: [schema]} = blueprint\n\n    type_ast = build_types(schema.type_artifacts)\n    directive_ast = build_directives(schema.directive_artifacts)\n\n    type_list =\n      Map.new(schema.type_definitions, fn type_def ->\n        {type_def.identifier, type_def.name}\n      end)\n\n    referenced_types =\n      for type_def <- schema.type_definitions,\n          type_def.__private__[:__absinthe_referenced__],\n          into: %{},\n          do: {type_def.identifier, type_def.name}\n\n    directive_list =\n      Map.new(schema.directive_definitions, fn type_def ->\n        {type_def.identifier, type_def.name}\n      end)\n\n    prototype_schema = Keyword.fetch!(opts, :prototype_schema)\n\n    metadata = build_metadata(schema)\n\n    implementors = build_implementors(schema)\n\n    body =\n      quote do\n        @moduledoc false\n\n        unquote_splicing(type_ast)\n        unquote_splicing(directive_ast)\n\n        def __absinthe_types__() do\n          __absinthe_types__(:referenced)\n        end\n\n        def __absinthe_types__(:referenced) do\n          unquote(Macro.escape(referenced_types))\n        end\n\n        def __absinthe_types__(:all) do\n          unquote(Macro.escape(type_list))\n        end\n\n        def __absinthe_directives__() do\n          unquote(Macro.escape(directive_list))\n        end\n\n        def __absinthe_interface_implementors__() do\n          unquote(Macro.escape(implementors))\n        end\n\n        def __absinthe_prototype_schema__() do\n          unquote(Macro.escape(prototype_schema))\n        end\n\n        unquote_splicing(metadata)\n      end\n\n    Module.create(module_name, body, Macro.Env.location(__ENV__))\n\n    {:ok, blueprint}\n  end\n\n  def build_metadata(schema) do\n    for type <- schema.type_definitions do\n      quote do\n        def __absinthe_reference__(unquote(type.identifier)) do\n          unquote(Macro.escape(type.__reference__))\n        end\n      end\n    end\n  end\n\n  def build_types(types) do\n    for type <- types do\n      if !type.definition,\n        do:\n          raise(\"\"\"\n          No definition set!\n          #{inspect(type)}\n          \"\"\")\n\n      ast = Macro.escape(type, unquote: true)\n\n      quote do\n        def __absinthe_type__(unquote(type.identifier)) do\n          unquote(ast)\n        end\n\n        def __absinthe_type__(unquote(type.name)) do\n          unquote(ast)\n        end\n      end\n    end\n    |> Enum.concat([\n      quote do\n        def __absinthe_type__(_type) do\n          nil\n        end\n      end\n    ])\n  end\n\n  def build_directives(directives) do\n    for type <- directives do\n      ast = Macro.escape(type)\n\n      quote do\n        def __absinthe_directive__(unquote(type.identifier)) do\n          unquote(ast)\n        end\n\n        def __absinthe_directive__(unquote(type.name)) do\n          unquote(ast)\n        end\n      end\n    end\n    |> Enum.concat([\n      quote do\n        def __absinthe_directive__(_type) do\n          nil\n        end\n      end\n    ])\n  end\n\n  defp build_implementors(schema) do\n    schema.type_definitions\n    |> Enum.filter(&match?(%Schema.InterfaceTypeDefinition{}, &1))\n    |> Map.new(fn iface ->\n      implementors =\n        Schema.InterfaceTypeDefinition.find_implementors(iface, schema.type_definitions)\n\n      {iface.identifier, Enum.sort(implementors)}\n    end)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,2,null,null,null,1,null,null,null,null,null,null,1,null,null],"name":"lib/spendable/user/resolver.ex","source":"defmodule Spendable.User.Resolver do\n  alias Spendable.Guardian\n  alias Spendable.Repo\n  alias Spendable.User\n\n  def current_user(_args, %{context: %{current_user: user}}) do\n    {:ok, user}\n  end\n\n  def create(args, _context) do\n    %User{}\n    |> User.changeset(args)\n    |> Repo.insert()\n    |> case do\n      {:ok, user} ->\n        {:ok, token, _claims} = Guardian.encode_and_sign(user)\n        {:ok, Map.put(user, :token, token)}\n\n      result ->\n        result\n    end\n  end\n\n  def update(args, %{context: %{current_user: user}}) do\n    user\n    |> User.changeset(args)\n    |> Repo.update()\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/budgets/allocation_template/factory.ex","source":"defmodule Spendable.Budgets.AllocationTemplate.Factory do\n  defmacro __using__(_opts) do\n    quote do\n      def allocation_template_factory(attrs) do\n        template = %Spendable.Budgets.AllocationTemplate{\n          name: \"Payday\",\n          lines: [\n            build(:allocation_template_line, user: attrs[:user]),\n            build(:allocation_template_line, user: attrs[:user])\n          ]\n        }\n\n        merge_attributes(template, attrs)\n      end\n    end\n  end\nend"},{"coverage":[null,null,null,17,null,null,null,null,null,null,null],"name":"lib/spendable/banks/category/schema.ex","source":"defmodule Spendable.Banks.Category do\n  use Ecto.Schema\n\n  schema \"categories\" do\n    field :external_id, :string\n    field :name, :string\n    field :parent_name, :string\n\n    belongs_to :parent, __MODULE__\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable_web/gettext.ex","source":"defmodule Spendable.Web.Gettext do\n  @moduledoc \"\"\"\n  A module providing Internationalization with a gettext-based API.\n\n  By using [Gettext](https://hexdocs.pm/gettext),\n  your module gains a set of macros for translations, for example:\n\n      import Spendable.Web.Gettext\n\n      # Simple translation\n      gettext(\"Here is the string to translate\")\n\n      # Plural translation\n      ngettext(\"Here is the string to translate\",\n               \"Here are the strings to translate\",\n               3)\n\n      # Domain-based translation\n      dgettext(\"errors\", \"Here is the error message to translate\")\n\n  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.\n  \"\"\"\n  use Gettext, otp_app: :spendable\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null],"name":"lib/spendable_web/views/error_view.ex","source":"defmodule Spendable.Web.ErrorView do\n  use Spendable.Web, :view\n\n  # If you want to customize a particular status code\n  # for a certain format, you may uncomment below.\n  # def render(\"500.html\", _assigns) do\n  #   \"Internal Server Error\"\n  # end\n\n  # By default, Phoenix returns the status message from\n  # the template name. For example, \"404.html\" becomes\n  # \"Not Found\".\n  def template_not_found(template, _assigns) do\n    Phoenix.Controller.status_message_from_template(template)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable.pb.ex","source":"defmodule SyncMemberRequest do\n  @moduledoc false\n  use Protobuf, syntax: :proto3\n\n  @type t :: %__MODULE__{\n          member_id: integer\n        }\n  defstruct [:member_id]\n\n  field :member_id, 1, type: :int64\nend\n\ndefmodule SendNotificationRequest do\n  @moduledoc false\n  use Protobuf, syntax: :proto3\n\n  @type t :: %__MODULE__{\n          user_id: integer,\n          title: String.t(),\n          body: String.t()\n        }\n  defstruct [:user_id, :title, :body]\n\n  field :user_id, 1, type: :int64\n  field :title, 2, type: :string\n  field :body, 3, type: :string\nend"},{"coverage":[null,null,null,null,null,null,null,null,3,null,null],"name":"lib/spendable/publishers/sync_member_request.ex","source":"defmodule Spendable.Publishers.SyncMemberRequest do\n  @topic if Application.get_env(:spendable, :env) == :prod,\n           do: \"spendable.sync-member-request\",\n           else: \"spendable-dev.sync-member-request\"\n\n  def publish(member_id) when is_integer(member_id) do\n    %SyncMemberRequest{member_id: member_id}\n    |> SyncMemberRequest.encode()\n    |> Weddell.publish(@topic)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable_web/endpoint.ex","source":"defmodule Spendable.Web.Endpoint do\n  use Phoenix.Endpoint, otp_app: :spendable\n  use Absinthe.Phoenix.Endpoint\n\n  # Serve at \"/\" the static files from \"priv/static\" directory.\n  #\n  # You should set gzip to true if you are running phoenix.digest\n  # when deploying your static files in production.\n  plug(Plug.Static,\n    at: \"/\",\n    from: :spendable,\n    gzip: true,\n    only: ~w(\n      css\n      fonts\n      images\n      js\n      favicon.ico\n      favicon-16x16.png\n      favicon-32x32.png\n      android-chrome-192x192.png\n      android-chrome-512x512.png\n      apple-touch-icon.png\n      robots.txt\n      site.webmanifest\n    )\n  )\n\n  # Code reloading can be explicitly enabled under the\n  # :code_reloader configuration of your endpoint.\n  if code_reloading? do\n    socket \"/phoenix/live_reload/socket\", Phoenix.LiveReloader.Socket\n    plug Phoenix.LiveReloader\n    plug Phoenix.CodeReloader\n  end\n\n  plug Plug.RequestId\n  plug Plug.Logger\n\n  plug Plug.Parsers,\n    parsers: [:urlencoded, :multipart, :json],\n    pass: [\"*/*\"],\n    json_decoder: Phoenix.json_library()\n\n  plug Plug.MethodOverride\n  plug Plug.Head\n\n  # The session will be stored in the cookie and signed,\n  # this means its contents can be read but not tampered with.\n  # Set :encryption_salt if you would also like to encrypt it.\n  plug Plug.Session,\n    store: :cookie,\n    key: \"_spendable_key\",\n    signing_salt: \"kJiN34/t\"\n\n  plug Spendable.Web.Router\nend"},{"coverage":[null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,2,null,null,null,1,null,null],"name":"lib/spendable/budgets/budget/resolver.ex","source":"defmodule Spendable.Budgets.Budget.Resolver do\n  import Ecto.Query, only: [from: 2]\n\n  alias Spendable.Budgets.Budget\n  alias Spendable.Repo\n\n  def list(_args, %{context: %{current_user: user}}) do\n    {:ok, from(Budget, where: [user_id: ^user.id]) |> Repo.all() |> Enum.sort_by(& &1.name)}\n  end\n\n  def get(_params, %{context: %{model: model}}) do\n    {:ok, model}\n  end\n\n  def create(params, %{context: %{current_user: user}}) do\n    %Budget{user_id: user.id}\n    |> Budget.changeset(params)\n    |> Repo.insert()\n  end\n\n  def update(params, %{context: %{model: model}}) do\n    model\n    |> Budget.changeset(params)\n    |> Repo.update()\n  end\n\n  def delete(_params, %{context: %{model: model}}) do\n    Repo.delete(model)\n  end\nend"},{"coverage":[null,null,null,null,null,32,1,null],"name":"lib/middleware/check_authentication.ex","source":"defmodule Spendable.Middleware.CheckAuthentication do\n  @behaviour Absinthe.Middleware\n\n  alias Absinthe.Resolution\n\n  def call(%{context: %{current_user: _}} = resolution, _config), do: resolution\n  def call(resolution, _config), do: resolution |> Resolution.put_result({:error, \"unauthenticated\"})\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/budgets/allocation_template_line/types.ex","source":"defmodule Spendable.Budgets.AllocationTemplateLine.Types do\n  use Absinthe.Schema.Notation\n  import Absinthe.Resolution.Helpers, only: [dataloader: 1]\n\n  object :allocation_template_line do\n    field :id, :id\n    field :amount, :string\n    field :budget, :budget, resolve: dataloader(Spendable)\n    field :allocation_template, :allocation_template, resolve: dataloader(Spendable)\n  end\n\n  input_object :allocation_template_line_input_object do\n    field :id, :id\n    field :amount, :string\n    field :budget_id, :id\n  end\nend"},{"coverage":[null,null,null,null,null,1,1,null,null,null,null,null,4,null,null,null,null,2,null,null,null,null,1,null,1,null,2,null,null,null,null,2,null,null,null,4,null,null,null,2,null,null,null,null,null,null,null,null,null,4,2,2,null,null,2,null,null],"name":"lib/spendable/banks/category/utils.ex","source":"defmodule Spendable.Banks.Category.Utils do\n  alias Spendable.Banks.Category\n  alias Spendable.Repo\n\n  def get_categories do\n    {:ok, %{body: %{\"categories\" => categories}}} = Plaid.categories()\n    categories\n  end\n\n  def import_categories(categories) do\n    categories\n    |> Enum.group_by(fn category ->\n      case Enum.reverse(category[\"hierarchy\"]) do\n        [_] ->\n          nil\n\n        [_name | parents] ->\n          Enum.join(parents, \":\")\n      end\n    end)\n    |> Enum.sort_by(fn\n      {nil, _} -> 0\n      {parent_key, _} -> parent_key |> String.split(\":\") |> length()\n    end)\n    |> Enum.reduce(%{}, fn {parent_key, categories}, existing_parents ->\n      insert_categories(parent_key, categories, existing_parents)\n      |> Map.merge(existing_parents)\n    end)\n  end\n\n  defp insert_categories(parent_key, categories, existing_parents) do\n    {_count, inserted_categories} =\n      Repo.insert_all(\n        Category,\n        Enum.map(categories, fn category ->\n          %{\n            name: List.last(category[\"hierarchy\"]),\n            external_id: category[\"category_id\"],\n            parent_id: existing_parents[parent_key],\n            parent_name: if(parent_key, do: parent_key |> String.split(\":\") |> Enum.join(\" / \"))\n          }\n        end),\n        conflict_target: :external_id,\n        on_conflict: {:replace, [:name, :parent_name]},\n        returning: [:id, :name]\n      )\n\n    inserted_categories\n    |> Enum.map(fn category ->\n      case parent_key do\n        nil -> {category.name, category.id}\n        _key -> {category.name <> \":\" <> parent_key, category.id}\n      end\n    end)\n    |> Map.new()\n  end\nend"},{"coverage":[null,null,0,0,null,null,null,null,0,null,null,null,0,0,null,null],"name":"lib/spendable/release.ex","source":"defmodule Spendable.Release do\n  def migrate do\n    for repo <- repos() do\n      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :up, all: true))\n    end\n  end\n\n  def rollback(repo, version) do\n    {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :down, to: version))\n  end\n\n  defp repos do\n    Application.load(:spendable)\n    Application.fetch_env!(:spendable, :ecto_repos)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null],"name":"lib/spendable/notifications/provider_enum.ex","source":"defmodule Notifications.ProviderEnum do\n  use Spendable.Utils.Enum,\n    type: :notification_provider,\n    values: [\n      %{name: :apns}\n    ]\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/banks/transaction/types.ex","source":"defmodule Spendable.Banks.Transaction.Types do\n  use Absinthe.Schema.Notation\n\n  object :bank_transaction do\n    field :amount, :string\n    field :date, :string\n    field :id, :id\n    field :name, :string\n    field :pending, :boolean\n  end\nend"},{"coverage":[null,null,null,42,null,null,null,null,null,null,null,null,null,4,null,null,null,null,null,4,null,null,null,null,null,null,null,null,1,null,null,null,null,1,3,null,null,null,null,null,2,1,1,null,null,null,null,null,42,null,null,null,null,null,null],"name":"lib/spendable_web/router.ex","source":"defmodule Spendable.Web.Router do\n  use Spendable.Web, :router\n\n  pipeline(:api) do\n    plug :accepts, [\"json\"]\n    plug Guardian.Plug.Pipeline, module: Spendable.Guardian\n    plug Guardian.Plug.VerifyHeader, realm: \"Bearer\"\n    plug Guardian.Plug.LoadResource, allow_blank: true\n    plug Spendable.Web.Context\n    plug Spendable.Web.HttpRedirect\n    plug :put_secure_browser_headers\n  end\n\n  pipeline(:public) do\n    plug :accepts, [\"json\"]\n    plug :put_secure_browser_headers\n    plug Spendable.Web.HttpRedirect\n  end\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_flash\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n    plug Spendable.Web.HttpRedirect\n  end\n\n  forward \"/_health\", HealthCheck\n\n  scope \"/\", Spendable.Web.Controllers do\n    pipe_through :public\n\n    get(\"/.well-known/apple-app-site-association\", WellKnown, :apple_app_site_association)\n    post(\"/plaid/webhook\", Plaid, :webhook)\n  end\n\n  scope \"/\", Spendable.Web.Controllers do\n    pipe_through :browser\n\n    get(\"/\", Site, :index)\n    get(\"/privacy-policy\", Site, :privacy_policy)\n    get(\"/contact-us\", Site, :contact_us)\n  end\n\n  scope \"/\" do\n    pipe_through :api\n\n    forward \"/graphql\", Absinthe.Plug,\n      schema: Spendable.Web.Schema,\n      analyze_complexity: true,\n      max_complexity: 500,\n      pipeline: {Spendable.Web.Schema, :pipeline}\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/banks/member/factory.ex","source":"defmodule Spendable.Banks.Member.Factory do\n  defmacro __using__(_opts) do\n    quote do\n      def bank_member_factory do\n        %Spendable.Banks.Member{\n          external_id: Faker.UUID.v4(),\n          institution_id: \"ins_1\",\n          name: \"Plaid\",\n          plaid_token: \"access-sandbox-898addd0-d983-45f8-a034-3b29d62794a7\",\n          provider: \"Plaid\",\n          status: \"Connected\"\n        }\n      end\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,4,null,null,null,null,null,0,null,null,null,null,null,16,null,null,null,null,16,null,null,null,null,null,null,null,null,8,null,null,8,8,null,null,null,null,null,null,null,null,8,8,8,8,8,8,8,8,null,null,null],"name":"lib/spendable/banks/providers/plaid/adapter.ex","source":"defmodule Spendable.Banks.Providers.Plaid.Adapter do\n  alias Spendable.Banks.Category\n  alias Spendable.Repo\n\n  def format(%{\"item\" => details}, user_id, :member) do\n    {:ok,\n     %{\n       body: %{\n         \"institution\" => %{\n           \"name\" => name,\n           \"logo\" => logo\n         }\n       }\n     }} = Plaid.institution(details[\"institution_id\"])\n\n    %{\n      external_id: details[\"item_id\"],\n      institution_id: details[\"institution_id\"],\n      logo: logo,\n      name: name,\n      provider: \"Plaid\",\n      status: details[\"error\"][\"error_code\"] || \"CONNECTED\",\n      user_id: user_id\n    }\n  end\n\n  def format(details, member_id, user_id, :account) do\n    %{\n      available_balance: details[\"balances\"][\"available\"],\n      balance: details[\"balances\"][\"current\"],\n      external_id: details[\"account_id\"],\n      bank_member_id: member_id,\n      name: details[\"official_name\"] || details[\"name\"],\n      number: details[\"mask\"],\n      sub_type: details[\"subtype\"],\n      type: details[\"type\"],\n      user_id: user_id\n    }\n  end\n\n  def format(details, account_id, user_id, :bank_transaction) do\n    %{\n      bank_account_id: account_id,\n      user_id: user_id,\n      category_id: Repo.get_by!(Category, external_id: details[\"category_id\"]).id,\n      amount: details[\"amount\"] |> to_string() |> Decimal.new() |> Decimal.minus() |> Decimal.round(2),\n      date: details[\"date\"],\n      external_id: details[\"transaction_id\"],\n      name: details[\"name\"],\n      pending: details[\"pending\"]\n    }\n  end\n\n  def format(bank_transaction, :transaction) do\n    %{\n      bank_account_id: bank_transaction.bank_account_id,\n      bank_transaction_id: bank_transaction.id,\n      user_id: bank_transaction.user_id,\n      category_id: bank_transaction.category_id,\n      amount: bank_transaction.amount,\n      date: bank_transaction.date,\n      name: bank_transaction.name\n    }\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null],"name":"lib/utils/enum.ex","source":"defmodule Spendable.Utils.Enum do\n  @moduledoc \"\"\"\n  Sets up EctoEnum and a GraphQL Enum.\n\n  Accepts a type and values opt. Type is the GraphQL enum type and values contains a list of maps defining the values.\n\n  ## Defining Values:\n  The only required field in a value is name.\n\n  You can also define the fields `as`, `deprecate`, `description` for the absinthe enum notation.\n\n  By default we store the string version of `name` as the database value, however, you can specify a `db_value` option to override that.\n\n  ```\n  type: :notification_provider,\n  values: [\n    %{name: :apns, as: :something_else, deprecate: \"This is why this is deprecated\", description: \"Describe the field\"},\n    ...\n  ]\n  ```\n  \"\"\"\n\n  defmacro __using__(opts) do\n    values = Enum.map(opts[:values] || [], fn {_, _, list} -> list end)\n\n    quote do\n      use EctoEnum, unquote(Enum.map(values, &{&1[:name], &1[:db_value] || \"#{&1[:name]}\"}))\n      use Absinthe.Schema.Notation\n\n      enum unquote(opts[:type]) do\n        unquote do\n          for item <- values do\n            quote do\n              value(\n                unquote(item[:name]),\n                unquote(as: item[:as] || item[:name], deprecate: item[:deprecate], description: item[:description])\n              )\n            end\n          end\n        end\n      end\n    end\n  end\nend"},{"coverage":[null,null,null,null,30,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,22,null,null],"name":"lib/spendable/banks/account/schema.ex","source":"defmodule Spendable.Banks.Account do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"bank_accounts\" do\n    field :external_id, :string\n    field :available_balance, :decimal\n    field :balance, :decimal\n    field :name, :string\n    field :number, :string\n    field :sub_type, :string\n    field :sync, :boolean, default: false\n    field :type, :string\n\n    belongs_to :user, Spendable.User\n    belongs_to :bank_member, Spendable.Banks.Member\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(model, attrs) do\n    model\n    |> cast(attrs, __schema__(:fields) -- [:id])\n    |> validate_required([:name, :user_id, :external_id, :bank_member_id, :sub_type, :type])\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,1,null,null,0,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,3,null,null,null,1,null,null],"name":"lib/spendable/transaction/resolver.ex","source":"defmodule Spendable.Transaction.Resolver do\n  import Ecto.Query, only: [from: 2]\n\n  alias Spendable.Repo\n  alias Spendable.Transaction\n\n  def list(args, %{context: %{current_user: user}}) do\n    {:ok,\n     from(Transaction,\n       where: [user_id: ^user.id],\n       order_by: [desc: :date, desc: :id],\n       limit: 100,\n       offset: ^(args[:offset] || 0)\n     )\n     |> Repo.all()}\n  end\n\n  def get(_args, %{context: %{model: model}}), do: {:ok, model}\n\n  def create(args, %{context: %{current_user: user}}) do\n    %Transaction{user_id: user.id}\n    |> Transaction.changeset(args)\n    |> Repo.insert()\n  end\n\n  def update(args, %{context: %{model: model}}) do\n    model\n    |> Repo.preload([:allocations, :tags])\n    |> Transaction.changeset(args)\n    |> Repo.update()\n  end\n\n  def delete(_args, %{context: %{model: model}}) do\n    Repo.delete(model)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,37,null,null,null,null,null,null,null,null,null,null,null,50,null,50,7,null,null,null,null,null],"name":"test/support/conn_case.ex","source":"defmodule Spendable.Web.ConnCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  tests that require setting up a connection.\n\n  Such tests rely on `Phoenix.ConnTest` and also\n  import other functionality to make it easier\n  to build common data structures and query the data layer.\n\n  Finally, if the test case interacts with the database,\n  it cannot be async. For this reason, every test runs\n  inside a transaction which is reset at the beginning\n  of the test unless the test case is marked as async.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  alias Ecto.Adapters.SQL.Sandbox\n\n  using do\n    quote do\n      # Import conveniences for testing with connections\n      use Phoenix.ConnTest\n      alias Spendable.Web.Router.Helpers, as: Routes\n\n      # The default endpoint for testing\n      @endpoint Spendable.Web.Endpoint\n    end\n  end\n\n  setup tags do\n    :ok = Sandbox.checkout(Spendable.Repo)\n\n    unless tags[:async] do\n      Sandbox.mode(Spendable.Repo, {:shared, self()})\n    end\n\n    {:ok, conn: Phoenix.ConnTest.build_conn()}\n  end\nend"},{"coverage":[null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,null,2,null,null,null,1,null,null,null,1,null,null],"name":"lib/spendable_web/controllers/site.ex","source":"defmodule Spendable.Web.Controllers.Site do\n  use Spendable.Web, :controller\n\n  def index(conn, params) do\n    position =\n      if params[\"email\"] do\n        Spendable.Repo.insert_all(\n          \"waitlist\",\n          [\n            %{email: params[\"email\"]}\n          ],\n          on_conflict: {:replace, [:email]},\n          conflict_target: [:email],\n          returning: [:id]\n        )\n        |> case do\n          {1, [%{id: id}]} -> id\n          _result -> nil\n        end\n      end\n\n    conn\n    |> put_layout(false)\n    |> render(\"index.html\", position: position)\n  end\n\n  def privacy_policy(conn, _params) do\n    render(conn, \"privacy-policy.html\")\n  end\n\n  def contact_us(conn, _params) do\n    render(conn, \"contact_us.html\")\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,42,null,null,null,null,32,null,null,null,null,null,null,null],"name":"lib/guardian.ex","source":"defmodule Spendable.Guardian do\n  use Guardian, otp_app: :spendable\n\n  def subject_for_token(resource, _claims) do\n    # You can use any value for the subject of your token but\n    # it should be useful in retrieving the resource later, see\n    # how it being used on `resource_from_claims/1` function.\n    # A unique `id` is a good subject, a non-unique email address\n    # is a poor subject.\n    sub = to_string(resource.id)\n    {:ok, sub}\n  end\n\n  def resource_from_claims(%{\"sub\" => id}) do\n    resource = Spendable.Repo.get!(Spendable.User, id)\n    {:ok, resource}\n  end\n\n  def resource_from_claims(_claims) do\n    {:error, :reason_for_error}\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,0,null,null,0,null,null],"name":"lib/mix/tasks/import_categories.ex","source":"defmodule Mix.Tasks.Import.Categories do\n  use Mix.Task\n\n  alias Spendable.Banks.Category.Utils\n\n  @shortdoc \"Import categories from Plaid.\"\n  def run(_opts) do\n    Mix.Task.run(\"app.start\")\n\n    Utils.get_categories()\n    |> Utils.import_categories()\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/banks/account/factory.ex","source":"defmodule Spendable.Banks.Account.Factory do\n  defmacro __using__(_opts) do\n    quote do\n      def bank_account_factory(attrs) do\n        bank_account = %Spendable.Banks.Account{\n          bank_member: build(:bank_member, user: attrs[:user]),\n          external_id: Faker.UUID.v4(),\n          name: \"Checking\",\n          balance: \"100.00\",\n          type: \"depository\",\n          sub_type: \"checking\",\n          sync: true\n        }\n\n        merge_attributes(bank_account, attrs)\n      end\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,37,37,37,null,null,null,null,null,null,null,null,23,null,null,null,1,null,null,null,10,10,null,null],"name":"test/support/test_utils.ex","source":"defmodule Spendable.TestUtils do\n  import ExUnit.Assertions\n\n  alias Spendable.Guardian\n  alias Spendable.Repo\n  alias Spendable.User\n\n  def create_user do\n    email = \"#{Ecto.UUID.generate()}@example.com\"\n    user = %User{} |> User.changeset(%{email: email, password: \"password\"}) |> Repo.insert!()\n    {:ok, token, _} = Guardian.encode_and_sign(user)\n\n    {user, token}\n  end\n\n  def random_decimal(range, precision \\\\ 2) do\n    Enum.random(range)\n    |> Decimal.cast()\n    |> Decimal.div(100)\n    |> Decimal.round(precision)\n  end\n\n  def assert_published(data) when is_list(data) do\n    Enum.each(data, &assert_published/1)\n  end\n\n  def assert_published(%{__struct__: module} = data) do\n    encoded_data = module.encode(data)\n    assert_receive ^encoded_data, 1000\n  end\nend"},{"coverage":[null,null,null,null,null,2,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,null],"name":"lib/spendable/notification_settings/resolver.ex","source":"defmodule Spendable.Notifications.Settings.Resolver do\n  alias Spendable.Notifications.Settings\n  alias Spendable.Repo\n\n  def get_or_create(%{device_token: device_token}, %{context: %{current_user: user}}) do\n    case Repo.get_by(Settings, user_id: user.id, device_token: device_token) do\n      nil ->\n        %Settings{user_id: user.id}\n        |> Settings.changeset(%{device_token: device_token, enabled: true})\n        |> Repo.insert()\n\n      model ->\n        {:ok, model}\n    end\n  end\n\n  def update(args, %{context: %{model: model}}) do\n    model\n    |> Settings.changeset(args)\n    |> Repo.update()\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/budgets/budget/factory.ex","source":"defmodule Spendable.Budgets.Budget.Factory do\n  defmacro __using__(_opts) do\n    quote do\n      def budget_factory do\n        %Spendable.Budgets.Budget{\n          name: \"Food\"\n        }\n      end\n\n      def goal_factory do\n        %Spendable.Budgets.Budget{\n          goal: Spendable.TestUtils.random_decimal(500_000..1_000_000),\n          name: \"Vacation\"\n        }\n      end\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,3,null,3,null],"name":"lib/spendable/notifications/provider.ex","source":"defmodule Notifications.Provider do\n  @callback new(%{optional(any) => any}, Spendable.Notifications.Settings) ::\n              Pigeon.APNS.Notification | Pigeon.FCM.Notification\n  @callback push(Pigeon.APNS.Notification | Pigeon.FCM.Notification) :: :ok | :invalid_token\n\n  alias Notifications.Providers.APNS\n  alias Spendable.Notifications.Settings\n\n  def new!(message, %Settings{provider: :apns} = settings), do: APNS.new(message, settings)\n\n  def push!(%Pigeon.APNS.Notification{} = notification), do: APNS.push(notification)\nend"},{"coverage":[null,null,null,null,null,2,2,null,null,null,null,null,2,1,null,null,null,null],"name":"lib/spendable/auth/resolver.ex","source":"defmodule Spendable.Auth.Resolver do\n  alias Spendable.Auth.Utils\n  alias Spendable.Guardian\n\n  def sign_in_with_apple(params, _info) do\n    with {:ok, user} <- Utils.authenticate(params),\n         {:ok, token, _} <- Guardian.encode_and_sign(user) do\n      {:ok, Map.put(user, :token, token)}\n    end\n  end\n\n  def login(params, _info) do\n    with {:ok, user} <- Utils.authenticate(params),\n         {:ok, token, _} <- Guardian.encode_and_sign(user) do\n      {:ok, Map.put(user, :token, token)}\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,37,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,1,null,null,1,null,null,2,null,null,null,null,null,null,8,2,6,null,null,null,null,7,null,7,null,null],"name":"lib/spendable/budgets/budget/schema.ex","source":"defmodule Spendable.Budgets.Budget do\n  use Ecto.Schema\n  import Ecto.Changeset\n  import Ecto.Query, only: [from: 2]\n\n  alias Spendable.Budgets.Allocation\n  alias Spendable.Budgets.AllocationTemplateLine\n  alias Spendable.Repo\n\n  schema \"budgets\" do\n    field :adjustment, :decimal, default: Decimal.new(\"0.00\")\n    field :balance, :decimal, virtual: true\n    field :goal, :decimal\n    field :name, :string\n\n    belongs_to :user, Spendable.User\n    has_many :allocations, Allocation\n    has_many :allocation_template_lines, AllocationTemplateLine\n\n    timestamps()\n  end\n\n  def changeset(model, params \\\\ %{}) do\n    model\n    |> cast(params, [:adjustment, :goal, :name, :balance])\n    |> validate_required([:user_id, :name])\n    |> prepare_changes(fn\n      %{data: %{id: nil}, changes: %{balance: %Decimal{} = balance}} = changeset ->\n        put_change(changeset, :adjustment, balance)\n\n      %{data: %{id: id}, changes: %{balance: %Decimal{} = balance}} = changeset ->\n        put_change(changeset, :adjustment, Decimal.sub(balance, allocated(id)))\n\n      changeset ->\n        changeset\n    end)\n  end\n\n  def allocated(budget_id) do\n    from(Allocation, where: [budget_id: ^budget_id])\n    |> Repo.aggregate(:sum, :amount)\n    |> case do\n      nil -> Decimal.new(\"0.00\")\n      allocated -> allocated\n    end\n  end\n\n  def balance(budget) do\n    budget.id\n    |> allocated()\n    |> Decimal.add(budget.adjustment)\n  end\nend"},{"coverage":[null,null,14,null,null,null,null,14,null,null,null,null,1,null,null,null,null,null,null,null,1,null,null,null,null,4,null,null,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,1,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/banks/providers/plaid/client.ex","source":"defmodule Plaid do\n  def client do\n    middleware = [\n      {Tesla.Middleware.BaseUrl, Application.get_env(:spendable, Plaid)[:base_url]},\n      Tesla.Middleware.JSON\n    ]\n\n    Tesla.client(middleware)\n  end\n\n  def exchange_public_token(public_token) do\n    client()\n    |> Tesla.post(\"/item/public_token/exchange\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      public_token: public_token\n    })\n  end\n\n  def categories do\n    client() |> Tesla.post(\"/categories/get\", %{})\n  end\n\n  def institution(id) do\n    client()\n    |> Tesla.post(\"/institutions/get_by_id\", %{\n      institution_id: id,\n      public_key: Application.get_env(:spendable, Plaid)[:public_key],\n      options: %{\n        include_optional_metadata: true\n      }\n    })\n  end\n\n  def item(token) do\n    client()\n    |> Tesla.post(\"/item/get\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      access_token: token\n    })\n  end\n\n  def create_public_token(token) do\n    client()\n    |> Tesla.post(\"/item/public_token/create\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      access_token: token\n    })\n  end\n\n  def accounts(token) do\n    client()\n    |> Tesla.post(\"/accounts/get\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      access_token: token\n    })\n  end\n\n  def account_transactions(token, account_id, opts \\\\ []) do\n    count = opts[:count] || 500\n    offset = opts[:offset] || 0\n\n    client()\n    |> Tesla.post(\"/transactions/get\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      access_token: token,\n      start_date: Date.utc_today() |> Date.add(-92),\n      end_date: Date.utc_today(),\n      options: %{\n        account_ids: [account_id],\n        count: count,\n        offset: offset\n      }\n    })\n  end\nend"},{"coverage":[null,null,null,null,null,2,2,2,2,null,null,null,1,null,null,null,null,null,null,null,null,null,null,2,2,null,null,null,null,null,null,null,2,null,null,2,2,null,null],"name":"lib/spendable/auth/utils.ex","source":"defmodule Spendable.Auth.Utils do\n  alias Spendable.Repo\n  alias Spendable.User\n\n  def authenticate(%{token: token}) do\n    with %{fields: %{\"kid\" => kid}} <- JOSE.JWT.peek_protected(token),\n         {true, json_payload, _} <- JOSE.JWK.verify(token, apple_jwk(kid)),\n         {:ok, %{\"sub\" => apple_identifier}} <- Jason.decode(json_payload) do\n      case Spendable.Repo.get_by(Spendable.User, apple_identifier: apple_identifier) do\n        nil ->\n          %User{}\n          |> User.changeset(%{apple_identifier: apple_identifier})\n          |> Repo.insert()\n\n        user ->\n          {:ok, user}\n      end\n    else\n      _match -> {:error, \"Login failed\"}\n    end\n  end\n\n  def authenticate(params) do\n    with user when is_struct(user) <- Spendable.Repo.get_by(Spendable.User, email: String.downcase(params.email)),\n         true <- Bcrypt.verify_pass(params.password, user.password) do\n      {:ok, user}\n    else\n      _match -> {:error, \"Incorrect login credentials\"}\n    end\n  end\n\n  def apple_jwk(kid) do\n    {:ok, %{body: %{\"keys\" => keys}}} = Apple.public_keys()\n\n    keys\n    |> Enum.find(&(&1[\"kid\"] == kid))\n    |> JOSE.JWK.from()\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,2,null,null,null,2,null,null,null,null,16,2,null,null,null,2,null,null,2,2,null,null,null,null,null,2,null,2,16,null,8,8,null,16,null,16,null,null,null,null,1,1,1,null,1,1,null,1,null,1,0,null,null,null,null,null,null,8,null,8,null,null,null,null,8,null,null,0,null,null,8,null,null,8,7,null,7,7,7,null,null,null,8,null,null,0,null,null,null,null,null,null,1,null,0,null,null,1,1,null,1,1,null,1,null,null,null,7,null],"name":"lib/spendable/broadway/sync_member/sync_member.ex","source":"defmodule Spendable.Broadway.SyncMember do\n  use Broadway\n  import Ecto.Query, only: [from: 2]\n\n  alias Broadway.Message\n  alias Spendable.Banks.Account\n  alias Spendable.Banks.Member\n  alias Spendable.Banks.Providers.Plaid.Adapter\n  alias Spendable.Banks.Transaction, as: BankTransaction\n  alias Spendable.Publishers.SendNotificationRequest\n  alias Spendable.Repo\n  alias Spendable.Transaction\n\n  @producer if Application.get_env(:spendable, :env) == :test,\n              do: {Broadway.DummyProducer, []},\n              else:\n                {BroadwayCloudPubSub.Producer,\n                 subscription: \"projects/cloud-57/subscriptions/spendable.sync-member-request\"}\n\n  def start_link(_opts) do\n    Broadway.start_link(__MODULE__,\n      name: __MODULE__,\n      producer: [\n        module: @producer\n      ],\n      processors: [\n        default: []\n      ],\n      batchers: [\n        default: [\n          batch_size: 10,\n          batch_timeout: 2_000\n        ]\n      ]\n    )\n  end\n\n  def handle_message(_processor_name, message, _context) do\n    Message.update_data(message, &process_data/1)\n  end\n\n  def handle_batch(_batch_name, messages, _batch_info, _context) do\n    messages\n  end\n\n  defp process_data(data) do\n    %SyncMemberRequest{member_id: member_id} = SyncMemberRequest.decode(data)\n\n    Repo.get(Member, member_id)\n    |> sync_member()\n    |> sync_accounts()\n    |> Enum.filter(& &1.sync)\n    |> Enum.each(&sync_transactions/1)\n  end\n\n  defp sync_member(member) when is_struct(member) do\n    {:ok, %{body: details}} = Plaid.item(member.plaid_token)\n\n    member\n    |> Member.changeset(Adapter.format(details, member.user_id, :member))\n    |> Repo.update!()\n  end\n\n  defp sync_member(nil), do: :ok\n\n  defp sync_accounts(member) do\n    {:ok, %{body: %{\"accounts\" => accounts_details}}} = Plaid.accounts(member.plaid_token)\n\n    Enum.map(accounts_details, fn account_details ->\n      Repo.get_by(Account, user_id: member.user_id, external_id: account_details[\"account_id\"])\n      |> case do\n        nil -> struct(Account)\n        account -> account\n      end\n      |> Account.changeset(Adapter.format(account_details, member.id, member.user_id, :account))\n      |> Repo.insert_or_update!()\n      |> Map.put(:bank_member, member)\n    end)\n  end\n\n  defp sync_transactions(account, opts \\\\ []) do\n    count = opts[:count] || 500\n    offset = opts[:offset] || 0\n    cursor = offset + count\n\n    {:ok, %{body: %{\"transactions\" => transactions_details} = response}} =\n      Plaid.account_transactions(account.bank_member.plaid_token, account.external_id, opts)\n\n    Enum.each(transactions_details, fn transaction_details -> sync_transaction(transaction_details, account) end)\n\n    with %{\"total_transactions\" => total} when total > cursor <- response do\n      sync_transactions(account, Keyword.merge(opts, offset: cursor))\n    end\n  end\n\n  defp sync_transaction(details, account) do\n    Repo.transaction(fn ->\n      %BankTransaction{}\n      |> BankTransaction.changeset(Adapter.format(details, account.id, account.user_id, :bank_transaction))\n      |> Repo.insert()\n      |> case do\n        {:ok, bank_transaction} ->\n          %Transaction{}\n          |> Transaction.changeset(Adapter.format(bank_transaction, :transaction))\n          |> Repo.insert!()\n          |> reassign_pending(details)\n\n        {:error, error} ->\n          Repo.rollback(error)\n      end\n    end)\n    |> case do\n      {:ok, transaction} = response ->\n        # if pending transaction id is set that means we have already sent a notification for the pending transaction\n        if is_nil(details[\"pending_transaction_id\"]) do\n          :ok =\n            SendNotificationRequest.publish(\n              account.user_id,\n              transaction.name,\n              \"$#{Decimal.abs(transaction.amount)}\"\n            )\n        end\n\n        response\n\n      response ->\n        response\n    end\n  end\n\n  defp reassign_pending(transaction, %{\"pending_transaction_id\" => pending_id}) when is_binary(pending_id) do\n    Repo.get_by(BankTransaction, external_id: pending_id, pending: true)\n    |> Repo.preload(:transaction)\n    |> case do\n      nil ->\n        transaction\n\n      pending_bank_transaction ->\n        from(Spendable.Budgets.Allocation, where: [transaction_id: ^pending_bank_transaction.transaction.id])\n        |> Repo.update_all(set: [transaction_id: transaction.id])\n\n        Repo.delete!(pending_bank_transaction.transaction)\n        Repo.delete!(pending_bank_transaction)\n\n        transaction\n    end\n  end\n\n  defp reassign_pending(transaction, _details), do: transaction\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/transaction/factory.ex","source":"defmodule Spendable.Transaction.Factory do\n  defmacro __using__(_opts) do\n    quote do\n      def transaction_factory do\n        %Spendable.Transaction{\n          amount: 10.25,\n          date: Date.utc_today(),\n          name: \"test\",\n          note: \"some notes\"\n        }\n      end\n    end\n  end\nend"},{"coverage":[null,null,null],"name":"lib/spendable_web/views/layout_view.ex","source":"defmodule Spendable.Web.LayoutView do\n  use Spendable.Web, :view\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/user/types.ex","source":"defmodule Spendable.User.Types do\n  use Absinthe.Schema.Notation\n\n  alias Spendable.Middleware.CheckAuthentication\n  alias Spendable.User.Resolver\n  alias Spendable.User.Utils\n\n  object :user do\n    field :id, :id\n    field :bank_limit, :integer\n    field :email, :string\n    field :token, :string\n\n    field :spendable, :string do\n      complexity(50)\n\n      resolve(fn user, _args, _resolution ->\n        {:ok, Utils.calculate_spendable(user)}\n      end)\n    end\n  end\n\n  object :user_queries do\n    field :current_user, :user do\n      middleware(CheckAuthentication)\n      resolve(&Resolver.current_user/2)\n    end\n  end\n\n  object :user_mutations do\n    field :create_user, :user do\n      arg(:email, non_null(:string))\n      arg(:password, non_null(:string))\n      resolve(&Resolver.create/2)\n    end\n\n    field :update_user, :user do\n      middleware(CheckAuthentication)\n      arg(:email, non_null(:string))\n      arg(:password, :string)\n      resolve(&Resolver.update/2)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/budgets/allocation/factory.ex","source":"defmodule Spendable.Budgets.Allocation.Factory do\n  defmacro __using__(_opts) do\n    quote do\n      def allocation_factory(attrs) do\n        allocation = %Spendable.Budgets.Allocation{\n          amount: Spendable.TestUtils.random_decimal(500..100_000),\n          budget: build(:budget, user: attrs[:user]),\n          transaction: build(:transaction, user: attrs[:user])\n        }\n\n        merge_attributes(allocation, Map.drop(attrs, [:user]))\n      end\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,0,null,null,null,null,50,null,null,1,null,1,null,null,49,null,null,null],"name":"lib/spendable_web/plugs/http_redirect.ex","source":"defmodule Spendable.Web.HttpRedirect do\n  @behaviour Plug\n  import Plug.Conn\n  require Logger\n\n  def init(opts), do: opts\n\n  def call(conn, _params) do\n    conn\n    |> get_req_header(\"x-forwarded-proto\")\n    |> case do\n      [\"http\"] ->\n        conn\n        |> put_resp_header(\"location\", \"https://spendable.money#{Phoenix.Controller.current_path(conn)}\")\n        |> resp(:moved_permanently, \"\")\n        |> halt()\n\n      _result ->\n        conn\n    end\n  end\nend"},{"coverage":[null,null,null,null,9,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8,null,null],"name":"lib/spendable/banks/transaction/schema.ex","source":"defmodule Spendable.Banks.Transaction do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"bank_transactions\" do\n    field :amount, :decimal\n    field :date, :date\n    field :external_id, :string\n    field :name, :string\n    field :pending, :boolean\n\n    belongs_to :category, Spendable.Banks.Category\n    belongs_to :user, Spendable.User\n    belongs_to :bank_account, Spendable.Banks.Account\n    has_one :transaction, Spendable.Transaction, foreign_key: :bank_transaction_id\n\n    timestamps()\n  end\n\n  def changeset(model, params \\\\ %{}) do\n    model\n    |> cast(params, __schema__(:fields) -- [:id])\n    |> validate_required([:user_id, :amount, :date, :external_id, :bank_account_id, :name, :pending])\n    |> unique_constraint(:external_id, name: :bank_transactions_bank_account_id_external_id_index)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/tag/types.ex","source":"defmodule Spendable.Tag.Types do\n  use Absinthe.Schema.Notation\n\n  alias Spendable.Middleware.CheckAuthentication\n  alias Spendable.Middleware.LoadModel\n  alias Spendable.Tag\n  alias Spendable.Tag.Resolver\n\n  object :tag do\n    field :id, :id\n    field :name, :string\n  end\n\n  object :tag_queries do\n    field :tags, list_of(:tag) do\n      middleware(CheckAuthentication)\n      resolve(&Resolver.list/2)\n    end\n  end\n\n  object :tag_mutations do\n    field :create_tag, :tag do\n      middleware(CheckAuthentication)\n      arg(:name, :string)\n      resolve(&Resolver.create/2)\n    end\n\n    field :update_tag, :tag do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: Tag)\n      arg(:id, non_null(:id))\n      arg(:name, :string)\n      resolve(&Resolver.update/2)\n    end\n\n    field :delete_tag, :tag do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: Tag)\n      arg(:id, non_null(:id))\n      resolve(&Resolver.delete/2)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null],"name":"lib/spendable/repo.ex","source":"defmodule Spendable.Repo do\n  use Ecto.Repo,\n    otp_app: :spendable,\n    adapter: Ecto.Adapters.Postgres\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/notification_settings/types.ex","source":"defmodule Spendable.Notifications.Settings.Types do\n  use Absinthe.Schema.Notation\n\n  alias Spendable.Middleware.CheckAuthentication\n  alias Spendable.Middleware.LoadModel\n  alias Spendable.Notifications.Settings\n  alias Spendable.Notifications.Settings.Resolver\n\n  object :notification_settings do\n    field :id, :id\n    field :enabled, :boolean\n  end\n\n  object :notification_settings_queries do\n    field :notification_settings, :notification_settings do\n      middleware(CheckAuthentication)\n      arg(:device_token, non_null(:string))\n      resolve(&Resolver.get_or_create/2)\n    end\n  end\n\n  object :notification_settings_mutations do\n    field :update_notification_settings, :notification_settings do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: Settings)\n      arg(:id, non_null(:id))\n      arg(:enabled, non_null(:boolean))\n      resolve(&Resolver.update/2)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,1,null,null,null,1,null,1,null,null,null,null,null,null,1,null,null,null,1,null,null],"name":"lib/spendable/budgets/allocation_template/resolver.ex","source":"defmodule Spendable.Budgets.AllocationTemplate.Resolver do\n  import Ecto.Query, only: [from: 2]\n\n  alias Spendable.Budgets.AllocationTemplate\n  alias Spendable.Repo\n\n  def list(_parent, _args, %{context: %{current_user: user}}) do\n    {:ok, from(AllocationTemplate, where: [user_id: ^user.id]) |> Repo.all()}\n  end\n\n  def create(params, %{context: %{current_user: user}}) do\n    %AllocationTemplate{user_id: user.id}\n    |> AllocationTemplate.changeset(params)\n    |> Repo.insert()\n  end\n\n  def update(params, %{context: %{model: model}}) do\n    model\n    |> Repo.preload(:lines)\n    |> AllocationTemplate.changeset(params)\n    |> Repo.update()\n  end\n\n  def delete(_params, %{context: %{model: model}}) do\n    Repo.delete(model)\n  end\nend"},{"coverage":[null,null,null,null,13,null,null,null,null,null,null,null,null,null,null,null,3,null,null],"name":"lib/spendable/budgets/allocation_template_line/schema.ex","source":"defmodule Spendable.Budgets.AllocationTemplateLine do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"budget_allocation_template_lines\" do\n    field :amount, :decimal\n\n    belongs_to :budget, Spendable.Budgets.Budget\n    belongs_to :allocation_template, Spendable.Budgets.AllocationTemplate, foreign_key: :budget_allocation_template_id\n\n    timestamps()\n  end\n\n  def changeset(model, params \\\\ %{}) do\n    model\n    |> cast(params, __schema__(:fields) -- [:id])\n    |> validate_required([:budget_id, :amount])\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/banks/member/types.ex","source":"defmodule Spendable.Banks.Member.Types do\n  use Absinthe.Schema.Notation\n  import Absinthe.Resolution.Helpers, only: [dataloader: 1]\n\n  alias Spendable.Banks.Member\n  alias Spendable.Banks.Member.Resolver\n  alias Spendable.Middleware.CheckAuthentication\n  alias Spendable.Middleware.LoadModel\n\n  object :bank_member do\n    field :id, :id\n    field :external_id, :string\n    field :institution_id, :string\n    field :logo, :string\n    field :name, :string\n    field :provider, :string\n    field :status, :string\n    field :bank_accounts, list_of(:bank_account), resolve: dataloader(Spendable)\n  end\n\n  object :bank_member_queries do\n    field :bank_members, list_of(:bank_member) do\n      middleware(CheckAuthentication)\n      resolve(&Resolver.list/3)\n    end\n  end\n\n  object :bank_member_mutations do\n    field :create_bank_member, :bank_member do\n      middleware(CheckAuthentication)\n      arg(:public_token, non_null(:string))\n      resolve(&Resolver.create/2)\n    end\n\n    field :create_public_token, :string do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: Member)\n      arg(:id, non_null(:id))\n      resolve(&Resolver.create_public_token/2)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/banks/category/types.ex","source":"defmodule Spendable.Banks.Category.Types do\n  use Absinthe.Schema.Notation\n\n  alias Spendable.Banks.Category.Resolver\n  alias Spendable.Middleware.CheckAuthentication\n\n  object :category do\n    field :id, :id\n    field :name, :string\n    field :parent_name, :string\n  end\n\n  object :category_queries do\n    field :categories, list_of(:category) do\n      middleware(CheckAuthentication)\n      resolve(&Resolver.list/3)\n    end\n  end\nend"},{"coverage":[null,null,null],"name":"lib/spendable_web/views/site_view.ex","source":"defmodule Spendable.Web.Controllers.SiteView do\n  use Spendable.Web, :view\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,3,null,null,null,null,3,null,null,null,null,null],"name":"lib/spendable/notifications/providers/apns.ex","source":"defmodule Notifications.Providers.APNS do\n  @behaviour Notifications.Provider\n\n  alias Pigeon.APNS\n  alias Pigeon.APNS.Notification\n  alias Spendable.Notifications.Settings\n\n  @impl Notifications.Provider\n  def new(message, %Settings{} = settings) do\n    Notification.new(message, settings.device_token, \"fiftysevenmedia.Spendable\")\n  end\n\n  @impl Notifications.Provider\n  def push(%Notification{} = notification) do\n    case APNS.push(notification) do\n      %Notification{response: :success} -> :ok\n      %Notification{response: :bad_device_token} -> :invalid_token\n    end\n  end\nend"},{"coverage":[null,null,null,null,17,null,null,null,null,null,null,null,null,null,null,null,2,null,null],"name":"lib/spendable/tag/schema.ex","source":"defmodule Spendable.Tag do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"tags\" do\n    field :name, :string\n\n    belongs_to :user, Spendable.User\n\n    timestamps()\n  end\n\n  def changeset(model, params \\\\ %{}) do\n    model\n    |> cast(params, __schema__(:fields) -- [:id])\n    |> validate_required([:name, :user_id])\n    |> unique_constraint(:name, name: :tags_user_id_name_index)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/tag/factory.ex","source":"defmodule Spendable.Tag.Factory do\n  defmacro __using__(_opts) do\n    quote do\n      def tag_factory do\n        %Spendable.Tag{\n          name: \"My Tag\"\n        }\n      end\n    end\n  end\nend"},{"coverage":[null,null,null,null,15,null,null,null,null,null,null,null,null,null,null,null,4,null,null],"name":"lib/spendable/budgets/allocation/schema.ex","source":"defmodule Spendable.Budgets.Allocation do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"budget_allocations\" do\n    field :amount, :decimal\n\n    belongs_to :budget, Spendable.Budgets.Budget\n    belongs_to :transaction, Spendable.Transaction\n\n    timestamps()\n  end\n\n  def changeset(model, params \\\\ %{}) do\n    model\n    |> cast(params, __schema__(:fields) -- [:id])\n    |> validate_required([:budget_id, :amount])\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,1,null,null,null,null,null,1,null,null,null,1,null,null],"name":"lib/spendable/tag/resolver.ex","source":"defmodule Spendable.Tag.Resolver do\n  import Ecto.Query, only: [from: 2]\n\n  alias Spendable.Repo\n  alias Spendable.Tag\n\n  def list(_args, %{context: %{current_user: user}}) do\n    {:ok,\n     from(Tag,\n       where: [user_id: ^user.id],\n       order_by: :name\n     )\n     |> Repo.all()}\n  end\n\n  def create(args, %{context: %{current_user: user}}) do\n    %Tag{user_id: user.id}\n    |> Tag.changeset(args)\n    |> Repo.insert()\n  end\n\n  def update(args, %{context: %{model: model}}) do\n    model\n    |> Tag.changeset(args)\n    |> Repo.update()\n  end\n\n  def delete(_args, %{context: %{model: model}}) do\n    Repo.delete(model)\n  end\nend"},{"coverage":[null,null,null,0,null,null,42,10,32,null,null,null],"name":"lib/spendable_web/plugs/context.ex","source":"defmodule Spendable.Web.Context do\n  @behaviour Plug\n\n  def init(opts), do: opts\n\n  def call(conn, _params) do\n    case Guardian.Plug.current_resource(conn) do\n      nil -> conn\n      user -> Absinthe.Plug.put_options(conn, context: %{current_user: user})\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,31,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,12,null,null,1,null,null,2,null,null,9,null],"name":"lib/spendable/transaction/schema.ex","source":"defmodule Spendable.Transaction do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  alias Spendable.Repo\n\n  schema \"transactions\" do\n    field :amount, :decimal\n    field :date, :date\n    field :name, :string\n    field :note, :string\n\n    belongs_to :bank_transaction, Spendable.Banks.Transaction\n    belongs_to :category, Spendable.Banks.Category\n    belongs_to :user, Spendable.User\n\n    has_many :allocations, Spendable.Budgets.Allocation, on_replace: :delete\n\n    many_to_many :tags, Spendable.Tag, join_through: \"transaction_tags\", on_replace: :delete, unique: true\n\n    timestamps()\n  end\n\n  def changeset(model, params \\\\ %{}) do\n    model\n    |> cast(params, __schema__(:fields) -- [:id])\n    |> validate_required([:user_id, :amount, :date])\n    |> cast_assoc(:allocations)\n    |> maybe_put_tags(params)\n  end\n\n  defp maybe_put_tags(changeset, %{tag_ids: []}), do: put_assoc(changeset, :tags, [])\n\n  defp maybe_put_tags(changeset, %{tag_ids: tag_ids}) when is_list(tag_ids) do\n    put_assoc(changeset, :tags, Enum.map(tag_ids, &Repo.get!(Spendable.Tag, &1)))\n  end\n\n  defp maybe_put_tags(changeset, _params), do: changeset\nend"},{"coverage":[null,null,2,null,null,null,null,2,null,null,2,null],"name":"lib/spendable/auth/apple/client.ex","source":"defmodule Apple do\n  def client do\n    middleware = [\n      {Tesla.Middleware.BaseUrl, \"https://appleid.apple.com\"},\n      Tesla.Middleware.JSON\n    ]\n\n    Tesla.client(middleware)\n  end\n\n  def public_keys, do: client() |> Tesla.get(\"/auth/keys\")\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,1,null,null],"name":"lib/utils/health_check.ex","source":"defmodule HealthCheck do\n  @moduledoc \"\"\"\n  Generic health check endpoint for Phoenix/Plug web apps.\n  You can provide an optional `resp_body` argument when mounting the plug that will override the default response body.\n  Usage:\n    Include within your phoenix router.ex file\n    `forward \"/_health\", HealthCheckup, resp_body: \"I'm up!\"`\n  Example:\n    GET /_health\n    HTTP/1.1 200 OK\n    I'm up!\n  \"\"\"\n\n  import Plug.Conn\n\n  @type options :: [resp_body: String.t()]\n\n  @resp_body \"ok\"\n\n  @spec init(options) :: options\n  def init(opts \\\\ []) do\n    [resp_body: opts[:resp_body] || @resp_body]\n  end\n\n  @spec call(Plug.Conn.t(), options) :: Plug.Conn.t()\n  def call(%Plug.Conn{} = conn, opts) do\n    send_resp(conn, 200, opts[:resp_body])\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/banks/category/resolver.ex","source":"defmodule Spendable.Banks.Category.Resolver do\n  import Ecto.Query, only: [from: 2]\n\n  alias Spendable.Banks.Category\n  alias Spendable.Repo\n\n  def list(_parent, _args, _resolution) do\n    {:ok, from(c in Category, order_by: fragment(\"lower(?)\", c.name)) |> Repo.all()}\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,2,null,null,null,2,null,null,null,2,null,null,null,3,null,1,null,null,null,null],"name":"lib/spendable/broadway/send_notification/send_notification.ex","source":"defmodule Spendable.Broadway.SendNotification do\n  use Broadway\n  import Ecto.Query, only: [from: 2]\n\n  alias Broadway.Message\n  alias Spendable.Repo\n\n  @producer if Application.get_env(:spendable, :env) == :test,\n              do: {Broadway.DummyProducer, []},\n              else:\n                {BroadwayCloudPubSub.Producer,\n                 subscription: \"projects/cloud-57/subscriptions/spendable.send-notification-request\"}\n\n  def start_link(_opts) do\n    Broadway.start_link(__MODULE__,\n      name: __MODULE__,\n      producer: [\n        module: @producer\n      ],\n      processors: [\n        default: []\n      ],\n      batchers: [\n        default: [\n          batch_size: 10,\n          batch_timeout: 2_000\n        ]\n      ]\n    )\n  end\n\n  def handle_message(_processor_name, message, _context) do\n    Message.update_data(message, &process_data/1)\n  end\n\n  def handle_batch(_batch_name, messages, _batch_info, _context) do\n    messages\n  end\n\n  defp process_data(data) do\n    %SendNotificationRequest{user_id: user_id, title: title, body: body} = SendNotificationRequest.decode(data)\n\n    from(Spendable.Notifications.Settings, where: [user_id: ^user_id, enabled: true])\n    |> Repo.all()\n    |> Enum.each(fn settings ->\n      %{\"title\" => title, \"body\" => body}\n      |> Notifications.Provider.new!(settings)\n      |> Notifications.Provider.push!()\n      |> case do\n        :ok -> :ok\n        :invalid_token -> Repo.delete!(settings)\n      end\n    end)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,2,null,null,null,1,null,1,1,1,1,null,null,1,null,1,null,1,null,null,null,0,null,null,null,null,null,null,null,1,null,null,null,null,null],"name":"lib/spendable/banks/member/resolver.ex","source":"defmodule Spendable.Banks.Member.Resolver do\n  require Logger\n  import Ecto.Query, only: [from: 2]\n\n  alias Spendable.Banks.Member\n  alias Spendable.Banks.Providers.Plaid.Adapter\n  alias Spendable.Publishers.SyncMemberRequest\n  alias Spendable.Repo\n\n  def list(_parent, _args, %{context: %{current_user: user}}) do\n    {:ok, from(Member, where: [user_id: ^user.id]) |> Repo.all()}\n  end\n\n  def create(%{public_token: token}, %{context: %{current_user: user}}) do\n    count = from(Member, where: [user_id: ^user.id]) |> Repo.aggregate(:count, :id)\n\n    if count < user.bank_limit do\n      {:ok, %{body: %{\"access_token\" => token}}} = Plaid.exchange_public_token(token)\n      Logger.info(\"New plaid member token: #{token}\")\n      {:ok, %{body: details}} = Plaid.item(token)\n\n      %Member{plaid_token: token}\n      |> Member.changeset(Adapter.format(details, user.id, :member))\n      |> Repo.insert()\n      |> case do\n        {:ok, member} ->\n          :ok = SyncMemberRequest.publish(member.id)\n          {:ok, member}\n\n        result ->\n          result\n      end\n    else\n      {:error, \"Bank limit reached\"}\n    end\n  end\n\n  def create_public_token(_params, %{context: %{model: model}}) do\n    case Plaid.create_public_token(model.plaid_token) do\n      {:ok, %{body: %{\"public_token\" => token}}} -> {:ok, token}\n      _error -> {:error, \"couldn't create token\"}\n    end\n  end\nend"},{"coverage":[null,null,null,null,8,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,null],"name":"lib/spendable/notification_settings/schema.ex","source":"defmodule Spendable.Notifications.Settings do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"notification_settings\" do\n    field :device_token, :string\n    field :enabled, :boolean, default: false\n    field :provider, Notifications.ProviderEnum\n\n    belongs_to :user, Spendable.User\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(user, attrs) do\n    user\n    |> cast(attrs, [:device_token, :user_id, :enabled])\n    |> unique_constraint(:device_token, name: :notification_settings_user_id_device_token_index)\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/transaction/types.ex","source":"defmodule Spendable.Transaction.Types do\n  use Absinthe.Schema.Notation\n  import Absinthe.Resolution.Helpers, only: [dataloader: 1]\n\n  alias Spendable.Middleware.CheckAuthentication\n  alias Spendable.Middleware.LoadModel\n  alias Spendable.Transaction\n  alias Spendable.Transaction.Resolver\n\n  object :transaction do\n    field :id, :id\n    field :amount, :string\n    field :date, :string\n    field :name, :string\n    field :note, :string\n\n    field :allocations, list_of(:allocation), resolve: dataloader(Spendable)\n    field :bank_transaction, :bank_transaction, resolve: dataloader(Spendable)\n    field :category, :category, resolve: dataloader(Spendable)\n    field :tags, list_of(:tag), resolve: dataloader(Spendable)\n  end\n\n  object :transaction_queries do\n    field :transactions, list_of(:transaction) do\n      middleware(CheckAuthentication)\n      arg(:offset, :integer)\n      resolve(&Resolver.list/2)\n    end\n\n    field :transaction, :transaction do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: Transaction)\n      arg(:id, non_null(:id))\n      resolve(&Resolver.get/2)\n    end\n  end\n\n  object :transaction_mutations do\n    field :create_transaction, :transaction do\n      middleware(CheckAuthentication)\n      arg(:amount, :string)\n      arg(:category_id, :id)\n      arg(:date, :string)\n      arg(:name, :string)\n      arg(:note, :string)\n      arg(:allocations, list_of(:allocation_input_object))\n      arg(:tag_ids, list_of(:id))\n      resolve(&Resolver.create/2)\n    end\n\n    field :update_transaction, :transaction do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: Transaction)\n      arg(:id, non_null(:id))\n      arg(:amount, :string)\n      arg(:category_id, :id)\n      arg(:date, :string)\n      arg(:name, :string)\n      arg(:note, :string)\n      arg(:allocations, list_of(:allocation_input_object))\n      arg(:tag_ids, list_of(:id))\n      resolve(&Resolver.update/2)\n    end\n\n    field :delete_transaction, :transaction do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: Transaction)\n      arg(:id, non_null(:id))\n      resolve(&Resolver.delete/2)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/spendable/budgets/allocation_template/types.ex","source":"defmodule Spendable.Budgets.AllocationTemplate.Types do\n  use Absinthe.Schema.Notation\n  import Absinthe.Resolution.Helpers, only: [dataloader: 1]\n\n  alias Spendable.Budgets.AllocationTemplate\n  alias Spendable.Budgets.AllocationTemplate.Resolver\n  alias Spendable.Middleware.CheckAuthentication\n  alias Spendable.Middleware.LoadModel\n\n  object :allocation_template do\n    field :id, :id\n    field :name, :string\n    field :lines, list_of(:allocation_template_line), resolve: dataloader(Spendable)\n  end\n\n  object :allocation_template_queries do\n    field :allocation_templates, list_of(:allocation_template) do\n      middleware(CheckAuthentication)\n      resolve(&Resolver.list/3)\n    end\n  end\n\n  object :allocation_template_mutations do\n    field :create_allocation_template, :allocation_template do\n      middleware(CheckAuthentication)\n      arg(:name, :string)\n      arg(:lines, list_of(:allocation_template_line_input_object))\n      resolve(&Resolver.create/2)\n    end\n\n    field :update_allocation_template, :allocation_template do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: AllocationTemplate)\n      arg(:id, non_null(:id))\n      arg(:name, :string)\n      arg(:lines, list_of(:allocation_template_line_input_object))\n      resolve(&Resolver.update/2)\n    end\n\n    field :delete_allocation_template, :allocation_template do\n      middleware(CheckAuthentication)\n      middleware(LoadModel, module: AllocationTemplate)\n      arg(:id, non_null(:id))\n      resolve(&Resolver.delete/2)\n    end\n  end\nend"},{"coverage":[null,null,null,null,1,null,null,null,null,null,null],"name":"lib/spendable_web/controllers/well_known.ex","source":"defmodule Spendable.Web.Controllers.WellKnown do\n  use Spendable.Web, :controller\n\n  def apple_app_site_association(conn, _params) do\n    json(conn, %{\n      webcredentials: %{\n        apps: [\"fiftysevenmedia.Spendable\"]\n      }\n    })\n  end\nend"},{"coverage":[null,null,null,null,105,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,46,null,null,null,42,null,null,4,null],"name":"lib/spendable/user/schema.ex","source":"defmodule Spendable.User do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"users\" do\n    field :apple_identifier, :string\n    field :bank_limit, :integer\n    field :email, :string\n    field :password, :string\n\n    has_many :notification_settings, Spendable.Notifications.Settings\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(user, attrs) do\n    user\n    |> cast(attrs, [:apple_identifier, :email, :password])\n    |> hash_password()\n    |> unique_constraint(:email, name: :users_email_index)\n    |> unique_constraint(:apple_identifier, name: :users_apple_identifier_index)\n  end\n\n  defp hash_password(%{changes: %{password: plain_text}} = changeset) do\n    put_change(changeset, :password, Bcrypt.hash_pwd_salt(plain_text))\n  end\n\n  defp hash_password(changeset), do: changeset\nend"}]}