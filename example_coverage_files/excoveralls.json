{"source_files":[{"name":"lib/spendable/resources/transaction.ex","source":"defmodule Spendable.Transaction do\n  use Ash.Resource,\n    authorizers: [Ash.Policy.Authorizer],\n    data_layer: AshPostgres.DataLayer\n\n  alias Spendable.Budget\n  alias Spendable.BudgetAllocationTemplate\n  alias Spendable.Transaction.Storage\n\n  postgres do\n    repo(Spendable.Repo)\n    table \"transactions\"\n\n    custom_indexes do\n      index([\"bank_transaction_id\"])\n      index([\"user_id\"])\n    end\n  end\n\n  attributes do\n    uuid_primary_key :id\n\n    attribute :amount, :decimal, allow_nil?: false\n    attribute :date, :date, allow_nil?: false\n    attribute :name, :ci_string, allow_nil?: false\n    attribute :note, :ci_string\n    attribute :reviewed, :boolean, allow_nil?: false\n\n    timestamps()\n  end\n\n  relationships do\n    belongs_to :bank_transaction, Spendable.BankTransaction\n    belongs_to :user, Spendable.User, allow_nil?: false\n\n    has_many :budget_allocations, Spendable.BudgetAllocation\n  end\n\n  actions do\n    defaults [:read, :destroy]\n\n    create :create do\n      primary? true\n\n      change relate_actor(:user)\n\n      argument :budget_allocations, {:array, :map}\n      change manage_relationship(:budget_allocations, type: :create)\n\n      change Spendable.Transaction.Changes.AllocateSpendable\n    end\n\n    update :update do\n      primary? true\n\n      argument :budget_allocations, {:array, :map}\n\n      change manage_relationship(:budget_allocations,\n               on_lookup: :relate,\n               on_no_match: :create,\n               on_match: :update,\n               on_missing: :destroy\n             )\n\n      change Spendable.Transaction.Changes.AllocateSpendable\n    end\n\n    update :update_allocations do\n      argument :budget_allocations, {:array, :map}\n\n      change manage_relationship(:budget_allocations,\n               on_lookup: :relate,\n               on_no_match: :create,\n               on_match: :update,\n               on_missing: :destroy\n             )\n    end\n  end\n\n  policies do\n    policy always() do\n      authorize_if action(:create)\n      authorize_if expr(user_id == ^actor(:id))\n    end\n  end\n\n  def budget_form_options(user_id) do\n    Budget.form_options(user_id)\n  end\n\n  def template_form_options(user_id) do\n    BudgetAllocationTemplate.form_options(user_id)\n  end\n\n  def get_template(id) do\n    BudgetAllocationTemplate.get_template(id)\n  end\n\n  def list_transactions(user_id, opts) do\n    Storage.list_transactions(user_id, opts)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,null]},{"name":"lib/spendable/plaid/client.ex","source":"defmodule Plaid do\n  def client() do\n    middleware = [\n      {Tesla.Middleware.BaseUrl, Application.get_env(:spendable, Plaid)[:base_url]},\n      Tesla.Middleware.JSON\n    ]\n\n    Tesla.client(middleware)\n  end\n\n  def exchange_public_token(public_token) do\n    client()\n    |> Tesla.post(\"/item/public_token/exchange\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      public_token: public_token\n    })\n  end\n\n  def institution(id) do\n    client()\n    |> Tesla.post(\"/institutions/get_by_id\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      institution_id: id,\n      options: %{\n        include_optional_metadata: true\n      }\n    })\n  end\n\n  def item(token) do\n    client()\n    |> Tesla.post(\"/item/get\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      access_token: token\n    })\n  end\n\n  def create_link_token(user_id, access_token \\\\ nil)\n\n  def create_link_token(user_id, nil) do\n    client()\n    |> Tesla.post(\"/link/token/create\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      client_name: \"Spendable\",\n      country_codes: [\"US\"],\n      language: \"en\",\n      products: [\"transactions\"],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      user: %{client_user_id: \"#{user_id}\"},\n      webhook: \"https://spendable.money/plaid/webhook\"\n    })\n  end\n\n  def create_link_token(user_id, access_token) do\n    client()\n    |> Tesla.post(\"/link/token/create\", %{\n      # access_token is passed for existing items, for example to verify micro deposits\n      # do not pass products with this request or it will fail.\n      access_token: access_token,\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      client_name: \"Spendable\",\n      country_codes: [\"US\"],\n      language: \"en\",\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      user: %{client_user_id: \"#{user_id}\"},\n      webhook: \"https://spendable.money/plaid/webhook\"\n    })\n  end\n\n  def accounts(token) do\n    client()\n    |> Tesla.post(\"/accounts/get\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      access_token: token\n    })\n  end\n\n  def account_transactions(token, account_id, opts \\\\ []) do\n    count = opts[:count] || 500\n    offset = opts[:offset] || 0\n\n    client()\n    |> Tesla.post(\"/transactions/get\", %{\n      client_id: Application.get_env(:spendable, Plaid)[:client_id],\n      secret: Application.get_env(:spendable, Plaid)[:secret_key],\n      access_token: token,\n      start_date: Date.utc_today() |> Date.add(-92),\n      end_date: Date.utc_today(),\n      options: %{\n        account_ids: [account_id],\n        count: count,\n        offset: offset\n      }\n    })\n  end\nend","coverage":[null,null,9,null,null,null,null,9,null,null,null,null,0,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,1,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,2,null,null,null,null,null,null,null,1,1,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable/publishers/sync_member_request.ex","source":"defmodule Spendable.Publishers.SyncMemberRequest do\n  alias Google.PubSub\n\n  require Application\n\n  @topic if Application.compile_env(:spendable, :env) == :prod,\n           do: \"spendable.sync-member-request\",\n           else: \"spendable-dev.sync-member-request\"\n\n  defp pubsub(), do: Application.get_env(:mox, :pubsub, PubSub)\n\n  def publish(member_id) when is_binary(member_id) do\n    %Banks.V1.SyncMemberRequest{member_id: member_id}\n    |> Banks.V1.SyncMemberRequest.encode()\n    |> pubsub().publish(@topic)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,1,null,null,null,null,1,null,null]},{"name":"lib/spendable_web/endpoint.ex","source":"defmodule SpendableWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :spendable\n\n  plug Spandex.Plug.StartTrace, tracer: Spendable.Tracer, ignored_routes: [\"/_health\"]\n\n  # The session will be stored in the cookie and signed,\n  # this means its contents can be read but not tampered with.\n  # Set :encryption_salt if you would also like to encrypt it.\n  @session_options [\n    store: :cookie,\n    key: \"_spendable_key\",\n    signing_salt: \"PdsDNWt7\",\n    same_site: \"Lax\"\n  ]\n\n  socket \"/live\", Phoenix.LiveView.Socket, websocket: [connect_info: [session: @session_options]]\n\n  # Serve at \"/\" the static files from \"priv/static\" directory.\n  #\n  # You should set gzip to true if you are running phx.digest\n  # when deploying your static files in production.\n  plug Plug.Static,\n    at: \"/\",\n    from: :spendable,\n    gzip: false,\n    only: SpendableWeb.static_paths()\n\n  # Code reloading can be explicitly enabled under the\n  # :code_reloader configuration of your endpoint.\n  if code_reloading? do\n    socket \"/phoenix/live_reload/socket\", Phoenix.LiveReloader.Socket\n    plug Phoenix.LiveReloader\n    plug Phoenix.CodeReloader\n    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :spendable\n  end\n\n  plug Phoenix.LiveDashboard.RequestLogger,\n    param_key: \"request_logger\",\n    cookie_key: \"request_logger\"\n\n  plug Plug.RequestId\n\n  plug Plug.Telemetry,\n    event_prefix: [:phoenix, :endpoint],\n    log: {__MODULE__, :log_level, []}\n\n  plug Plug.Parsers,\n    parsers: [:urlencoded, :multipart, :json],\n    pass: [\"*/*\"],\n    json_decoder: Phoenix.json_library()\n\n  plug Plug.MethodOverride\n  plug Plug.Head\n  plug Plug.Session, @session_options\n  plug SpendableWeb.Router\n\n  plug Spandex.Plug.AddContext, tracer: Spendable.Tracer\n  plug Spandex.Plug.EndTrace, tracer: Spendable.Tracer\n\n  def log_level(%{request_path: \"/_health\"}), do: false\n  def log_level(_conn), do: :info\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,14,null]},{"name":"lib/spendable/publishers/google_pubsub_client.ex","source":"defmodule Google.PubSub do\n  @behaviour Spendable.Behaviour.PubSub\n\n  def client() do\n    {:ok, project} = Goth.Config.get(:project_id)\n\n    %{type: type, token: token} = Goth.fetch!(Spendable.Goth)\n\n    middleware = [\n      {Tesla.Middleware.BaseUrl, \"https://pubsub.googleapis.com/v1/projects/#{project}/topics\"},\n      {Tesla.Middleware.Headers, [{\"authorization\", \"#{type} #{token}\"}]},\n      Tesla.Middleware.JSON\n    ]\n\n    Tesla.client(middleware)\n  end\n\n  @impl Spendable.Behaviour.PubSub\n  def publish(message, topic) do\n    client() |> Tesla.post(\"#{topic}:publish\", %{messages: [%{data: Base.encode64(message)}]})\n  end\nend","coverage":[null,null,null,null,0,null,0,null,0,0,0,null,null,null,0,null,null,null,null,0,null,null]},{"name":"lib/spendable/notifiers/sync_member.ex","source":"defmodule Spendable.Notifiers.SyncMember do\n  use Ash.Notifier\n\n  alias Spendable.Broadway.SyncMember\n  alias Spendable.Publishers.SyncMemberRequest\n\n  require Logger\n\n  def notify(%Ash.Notifier.Notification{\n        resource: Spendable.BankMember,\n        action: %{name: :create_from_public_token},\n        data: %{id: bank_member_id} = member\n      }) do\n    SyncMember.sync_accounts(member)\n    Logger.info(\"publishing sync member request for member: #{bank_member_id}\")\n    SyncMemberRequest.publish(bank_member_id)\n  end\n\n  def notify(_notification) do\n    :ok\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,24,null,null,null]},{"name":"lib/spendable/resources/user/calculations/spendable.ex","source":"defmodule Spendable.User.Calculations.Spendable do\n  use Ash.Calculation, type: :decimal\n\n  import Ecto.Query\n\n  alias Spendable.BankAccount\n  alias Spendable.Budget\n  alias Spendable.BudgetAllocation\n  alias Spendable.Repo\n\n  @impl Ash.Calculation\n  def calculate([user], _opts, _resolution) do\n    balance =\n      from(ba in BankAccount,\n        select:\n          fragment(\n            \"SUM(CASE WHEN ? = 'credit' THEN -? ELSE ? END)\",\n            ba.type,\n            ba.balance,\n            ba.balance\n          ),\n        where: ba.user_id == ^user.id and ba.sync\n      )\n      |> Repo.one()\n      |> Kernel.||(\"0.00\")\n\n    allocations_query =\n      from(a in BudgetAllocation,\n        where: a.user_id == ^user.id,\n        select: %{\n          budget_id: a.budget_id,\n          allocated: sum(a.amount)\n        },\n        group_by: a.budget_id\n      )\n\n    allocated =\n      from(a in subquery(allocations_query),\n        full_join: b in Budget,\n        on: a.budget_id == b.id,\n        select: fragment(\"SUM(ABS(COALESCE(?, 0) + ?))\", a.allocated, b.adjustment),\n        where: b.user_id == ^user.id,\n        # ignore budgets that are only used to track spending\n        where: b.track_spending_only == false\n      )\n      |> Repo.one()\n      |> Kernel.||(\"0.00\")\n\n    {:ok, [Decimal.sub(balance, allocated)]}\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,2,null,null,2,null,2,null,2,null,null,null,null,null,null,null,2,2,null,null,null,2,null,null,null,null,2,null,null,null,null]},{"name":"lib/spendable_web/router.ex","source":"defmodule SpendableWeb.Router do\n  use SpendableWeb, :router\n\n  forward \"/_health\", HealthCheck\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_live_flash\n    plug :put_root_layout, html: {SpendableWeb.Layouts, :root}\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\n\n  pipeline :api do\n    plug :accepts, [\"json\"]\n  end\n\n  scope \"/\", SpendableWeb do\n    pipe_through :browser\n\n    get \"/\", AuthController, :login\n    delete \"/logout\", AuthController, :delete\n  end\n\n  scope \"/\", SpendableWeb do\n    pipe_through :api\n\n    post \"/plaid/webhook\", PlaidController, :webhook\n  end\n\n  scope \"/auth\", SpendableWeb do\n    pipe_through :browser\n\n    get \"/:provider\", AuthController, :request\n    get \"/:provider/callback\", AuthController, :callback\n    post \"/:provider/callback\", AuthController, :callback\n  end\n\n  live_session :authenticated,\n    on_mount: [\n      {SpendableWeb.Live.UserAuth, :ensure_authenticated},\n      SpendableWeb.Live.Nav\n    ] do\n    scope \"/\", SpendableWeb.Live do\n      pipe_through [:browser]\n\n      live \"/budgets\", Budgets\n      live \"/transactions\", Transactions\n      live \"/templates\", Templates\n      live \"/banks\", Banks\n    end\n  end\n\n  # Enable LiveDashboard in development\n  if Application.compile_env(:spendable, :dev_routes) do\n    # If you want to use the LiveDashboard in production, you should put\n    # it behind authentication and allow only admins to access it.\n    # If your application does not have an admins-only section yet,\n    # you can use Plug.BasicAuth to set up some basic authentication\n    # as long as you are also using SSL (which you should anyway).\n    import Phoenix.LiveDashboard.Router\n\n    scope \"/dev\" do\n      pipe_through :browser\n\n      live_dashboard \"/dashboard\", metrics: SpendableWeb.Telemetry\n    end\n  end\nend","coverage":[null,null,null,1,null,4,null,null,null,null,null,null,null,null,3,null,null,null,null,null,null,1,1,null,null,null,null,null,3,null,null,null,null,null,0,0,0,null,null,null,null,null,null,null,null,null,null,2,0,2,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable/resources/budget_allocation_template_line/factory.ex","source":"defmodule Spendable.BudgetAllocationTemplateLine.Factory do\n  def default() do\n    %{\n      # Spendable.TestUtils.random_decimal(500..100_000)\n      amount: 1\n    }\n  end\nend","coverage":[null,null,0,null,null,null,null,null]},{"name":"lib/spendable.ex","source":"defmodule Spendable do\n  @moduledoc \"\"\"\n  Spendable keeps the contexts that define your domain\n  and business logic.\n\n  Contexts are also responsible for managing your data, regardless\n  if it comes from the database, an external API or others.\n  \"\"\"\nend","coverage":[null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable/resources/transactions/changes/allocate_spendable.ex","source":"defmodule Spendable.Transaction.Changes.AllocateSpendable do\n  use Ash.Resource.Change\n\n  alias Spendable.Utils\n\n  def change(changeset, _opts, %{actor: user}) do\n    Ash.Changeset.after_action(changeset, fn _changeset, transaction ->\n      transaction = Spendable.Api.load!(transaction, :budget_allocations)\n      spendable_id = Utils.get_spendable_id(user)\n      allocations = Enum.reject(transaction.budget_allocations, &(&1.budget_id == spendable_id))\n\n      allocated = Enum.reduce(allocations, Decimal.new(0), &Decimal.add(&1.amount, &2))\n      unallocated = Decimal.sub(transaction.amount, allocated)\n\n      unless Decimal.eq?(unallocated, 0) do\n        new_allocations = [%{amount: unallocated, budget_id: to_string(spendable_id)} | allocations]\n\n        transaction\n        |> Ash.Changeset.for_update(:update_allocations, %{budget_allocations: new_allocations}, actor: user)\n        |> Spendable.Api.update!()\n      end\n\n      {:ok, transaction}\n    end)\n  end\nend","coverage":[null,null,null,null,null,null,9,9,9,9,null,9,9,null,9,9,null,null,null,9,null,null,null,null,null,null]},{"name":"lib/spendable/resources/budget_allocation_template_line.ex","source":"defmodule Spendable.BudgetAllocationTemplateLine do\n  use Ash.Resource,\n    authorizers: [Ash.Policy.Authorizer],\n    data_layer: AshPostgres.DataLayer\n\n  postgres do\n    repo Spendable.Repo\n    table \"budget_allocation_template_lines\"\n\n    custom_indexes do\n      index [\"budget_id\"]\n      index [\"budget_allocation_template_id\"]\n      index [\"user_id\"]\n    end\n\n    references do\n      reference :budget_allocation_template, on_delete: :delete\n    end\n  end\n\n  attributes do\n    uuid_primary_key :id\n\n    attribute :amount, :decimal, allow_nil?: false\n\n    timestamps()\n  end\n\n  relationships do\n    belongs_to :budget, Spendable.Budget, allow_nil?: false\n\n    belongs_to :budget_allocation_template, Spendable.BudgetAllocationTemplate, allow_nil?: false\n\n    belongs_to :user, Spendable.User, allow_nil?: false\n  end\n\n  actions do\n    defaults [:read, :destroy]\n\n    create :create do\n      primary? true\n\n      change relate_actor(:user)\n\n      argument :budget_id, :string\n      change manage_relationship(:budget_id, :budget, type: :append_and_remove)\n    end\n\n    update :update do\n      primary? true\n\n      argument :budget_id, :string\n      change manage_relationship(:budget_id, :budget, type: :append_and_remove)\n    end\n  end\n\n  policies do\n    policy always() do\n      authorize_if action(:create)\n      authorize_if expr(user_id == ^actor(:id))\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable/resources/budget/calculations/spent.ex","source":"defmodule Spendable.Budget.Calculations.Spent do\n  use Ash.Calculation, type: :string\n\n  import Ecto.Query\n\n  alias Spendable.BudgetAllocation\n  alias Spendable.Repo\n  alias Spendable.Transaction\n\n  @impl Ash.Calculation\n  def calculate(budgets, _opts, %{month: month}) do\n    start_date = Timex.beginning_of_month(month)\n    end_date = Timex.end_of_month(start_date)\n    budget_ids = Enum.map(budgets, & &1.id)\n\n    query =\n      from ba in BudgetAllocation,\n        join: t in Transaction,\n        on: ba.transaction_id == t.id,\n        select: {\n          ba.budget_id,\n          sum(ba.amount) |> coalesce(^Decimal.new(0))\n        },\n        where: ba.budget_id in ^budget_ids,\n        where: t.date >= ^start_date,\n        where: t.date <= ^end_date,\n        where: ba.amount < 0,\n        group_by: :budget_id\n\n    spent_by_budget_id =\n      query\n      |> Repo.all()\n      |> Map.new()\n\n    spent_per_budget =\n      Enum.map(budgets, fn budget ->\n        Map.get(spent_by_budget_id, budget.id, Decimal.new(\"0\"))\n      end)\n\n    {:ok, spent_per_budget}\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,8,8,8,null,8,null,null,null,null,null,null,null,null,null,null,null,null,null,8,null,null,null,null,8,null,6,null,null,null,null,null]},{"name":"lib/spendable_web/components/layouts.ex","source":"defmodule SpendableWeb.Layouts do\n  use SpendableWeb, :html\n\n  embed_templates \"layouts/*\"\nend","coverage":[null,null,null,null,null]},{"name":"lib/spendable_web/telemetry.ex","source":"defmodule SpendableWeb.Telemetry do\n  use Supervisor\n  import Telemetry.Metrics\n\n  def start_link(arg) do\n    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_arg) do\n    children = [\n      # Telemetry poller will execute the given period measurements\n      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics\n      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}\n      # Add reporters as children of your supervision tree.\n      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}\n    ]\n\n    Supervisor.init(children, strategy: :one_for_one)\n  end\n\n  def metrics() do\n    [\n      # Phoenix Metrics\n      summary(\"phoenix.endpoint.start.system_time\",\n        unit: {:native, :millisecond}\n      ),\n      summary(\"phoenix.endpoint.stop.duration\",\n        unit: {:native, :millisecond}\n      ),\n      summary(\"phoenix.router_dispatch.start.system_time\",\n        tags: [:route],\n        unit: {:native, :millisecond}\n      ),\n      summary(\"phoenix.router_dispatch.exception.duration\",\n        tags: [:route],\n        unit: {:native, :millisecond}\n      ),\n      summary(\"phoenix.router_dispatch.stop.duration\",\n        tags: [:route],\n        unit: {:native, :millisecond}\n      ),\n      summary(\"phoenix.socket_connected.duration\",\n        unit: {:native, :millisecond}\n      ),\n      summary(\"phoenix.channel_join.duration\",\n        unit: {:native, :millisecond}\n      ),\n      summary(\"phoenix.channel_handled_in.duration\",\n        tags: [:event],\n        unit: {:native, :millisecond}\n      ),\n\n      # Database Metrics\n      summary(\"spendable.repo.query.total_time\",\n        unit: {:native, :millisecond},\n        description: \"The sum of the other measurements\"\n      ),\n      summary(\"spendable.repo.query.decode_time\",\n        unit: {:native, :millisecond},\n        description: \"The time spent decoding the data received from the database\"\n      ),\n      summary(\"spendable.repo.query.query_time\",\n        unit: {:native, :millisecond},\n        description: \"The time spent executing the query\"\n      ),\n      summary(\"spendable.repo.query.queue_time\",\n        unit: {:native, :millisecond},\n        description: \"The time spent waiting for a database connection\"\n      ),\n      summary(\"spendable.repo.query.idle_time\",\n        unit: {:native, :millisecond},\n        description: \"The time the connection spent waiting before being checked out for the query\"\n      ),\n\n      # VM Metrics\n      summary(\"vm.memory.total\", unit: {:byte, :kilobyte}),\n      summary(\"vm.total_run_queue_lengths.total\"),\n      summary(\"vm.total_run_queue_lengths.cpu\"),\n      summary(\"vm.total_run_queue_lengths.io\")\n    ]\n  end\n\n  defp periodic_measurements() do\n    [\n      # A module, function and arguments to be invoked periodically.\n      # This function must call :telemetry.execute/3 and a metric must be added above.\n      # {SpendableWeb, :count_users, []}\n    ]\n  end\nend","coverage":[null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,null,1,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null]},{"name":"lib/spendable/resources/bank_member/changes/create_bank_member.ex","source":"defmodule Spendable.BankMember.Changes.CreateBankMember do\n  use Ash.Resource.Change\n\n  import Ecto.Query\n\n  alias Spendable.BankMember\n  alias Spendable.Plaid.Adapter\n  alias Spendable.Repo\n\n  require Logger\n\n  def change(changeset, _opts, %{actor: user}) do\n    public_token = Ash.Changeset.get_argument(changeset, :public_token)\n\n    Ash.Changeset.before_action(changeset, fn changeset ->\n      case get_bank_member(public_token, user) do\n        {:ok, bank_member_data} ->\n          changeset\n          |> Ash.Changeset.force_change_attributes(bank_member_data)\n          |> Ash.Changeset.select(:plaid_token)\n\n        {:error, error} ->\n          Ash.Changeset.add_error(changeset, error)\n      end\n    end)\n  end\n\n  defp get_bank_member(public_token, user) do\n    count = from(BankMember, where: [user_id: ^user.id]) |> Repo.aggregate(:count, :id)\n\n    if count < user.bank_limit do\n      {:ok, %{body: %{\"access_token\" => token}}} = Plaid.exchange_public_token(public_token)\n      Logger.info(\"New plaid member token: #{token}\")\n\n      {:ok, %{body: details}} = Plaid.item(token)\n\n      bank_member =\n        details\n        |> Adapter.bank_member()\n        |> Map.put(:plaid_token, token)\n\n      {:ok, bank_member}\n    else\n      {:error, \"Bank limit reached\"}\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,0,null,null,0,null,null,null,null,null,0,null,0,0,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable/uxid.ex","source":"defmodule Spendable.UXID do\n  def generate(prefix), do: UXID.generate!(prefix: prefix)\nend","coverage":[null,0,null]},{"name":"lib/spendable_web/live/nav.ex","source":"defmodule SpendableWeb.Live.Nav do\n  import Phoenix.Component\n  import Phoenix.LiveView\n\n  def on_mount(:default, _params, _session, socket) do\n    {:cont,\n     socket\n     |> attach_hook(:active_tab, :handle_params, &set_active_tab/3)}\n  end\n\n  defp set_active_tab(_params, _url, socket) do\n    active_tab =\n      case socket.view do\n        SpendableWeb.Live.Budgets -> :budgets\n        SpendableWeb.Live.Transactions -> :transactions\n        SpendableWeb.Live.Banks -> :Banks\n        _view -> nil\n      end\n\n    {:cont, assign(socket, active_tab: active_tab)}\n  end\nend","coverage":[null,null,null,null,4,null,null,null,null,null,null,4,4,2,0,0,2,null,null,null,null,null]},{"name":"lib/spendable/resources/bank_member/calculations/plaid_link_token.ex","source":"defmodule Spendable.BankMember.Calculations.PlaidLinkToken do\n  use Ash.Calculation, type: :string\n\n  @impl Ash.Calculation\n  def calculate([bank_member], _opts, _resolution) do\n    with {:ok, %{body: %{\"link_token\" => token}}} <-\n           Plaid.create_link_token(bank_member.user_id, bank_member.plaid_token) do\n      {:ok, [token]}\n    end\n  end\nend","coverage":[null,null,null,null,null,1,1,null,null,null,null]},{"name":"lib/spendable_web/health_check.ex","source":"defmodule HealthCheck do\n  @moduledoc \"\"\"\n  Generic health check endpoint for Phoenix/Plug web apps.\n  You can provide an optional `resp_body` argument when mounting the plug that will override the default response body.\n  Usage:\n    Include within your phoenix router.ex file\n    `forward \"/_health\", HealthCheckup, resp_body: \"I'm up!\"`\n  Example:\n    GET /_health\n    HTTP/1.1 200 OK\n    I'm up!\n  \"\"\"\n\n  import Plug.Conn\n\n  @type options :: [resp_body: String.t()]\n\n  @resp_body \"ok\"\n\n  @spec init(options) :: options\n  def init(opts \\\\ []) do\n    [resp_body: opts[:resp_body] || @resp_body]\n  end\n\n  @spec call(Plug.Conn.t(), options) :: Plug.Conn.t()\n  def call(%Plug.Conn{} = conn, opts) do\n    send_resp(conn, 200, opts[:resp_body])\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,1,null,null]},{"name":"deps/mox/lib/mox.ex","source":"defmodule Mox do\n  @moduledoc ~S\"\"\"\n  Mox is a library for defining concurrent mocks in Elixir.\n\n  The library follows the principles outlined in\n  [\"Mocks and explicit contracts\"](https://dashbit.co/blog/mocks-and-explicit-contracts),\n  summarized below:\n\n    1. No ad-hoc mocks. You can only create mocks based on behaviours\n\n    2. No dynamic generation of modules during tests. Mocks are preferably defined\n       in your `test_helper.exs` or in a `setup_all` block and not per test\n\n    3. Concurrency support. Tests using the same mock can still use `async: true`\n\n    4. Rely on pattern matching and function clauses for asserting on the\n       input instead of complex expectation rules\n\n  ## Example\n\n  Imagine that you have an app that has to display the weather. At first,\n  you use an external API to give you the data given a lat/long pair:\n\n      defmodule MyApp.HumanizedWeather do\n        def display_temp({lat, long}) do\n          {:ok, temp} = MyApp.WeatherAPI.temp({lat, long})\n          \"Current temperature is #{temp} degrees\"\n        end\n\n        def display_humidity({lat, long}) do\n          {:ok, humidity} = MyApp.WeatherAPI.humidity({lat, long})\n          \"Current humidity is #{humidity}%\"\n        end\n      end\n\n  However, you want to test the code above without performing external\n  API calls. How to do so?\n\n  First, it is important to define the `WeatherAPI` behaviour that we want\n  to mock. And we will define a proxy functions that will dispatch to\n  the desired implementation:\n\n      defmodule MyApp.WeatherAPI do\n        @callback temp(MyApp.LatLong.t()) :: {:ok, integer()}\n        @callback humidity(MyApp.LatLong.t()) :: {:ok, integer()}\n\n        def temp(lat_long), do: impl().temp(lat_long)\n        def humidity(lat_long), do: impl().humidity(lat_long)\n        defp impl, do: Application.get_env(:my_app, :weather, MyApp.ExternalWeatherAPI)\n      end\n\n  By default, we will dispatch to MyApp.ExternalWeatherAPI, which now contains\n  the external API implementation.\n\n  If you want to mock the WeatherAPI behaviour during tests, the first step\n  is to define the mock with `defmock/2`, usually in your `test_helper.exs`,\n  and configure your application to use it:\n\n      Mox.defmock(MyApp.MockWeatherAPI, for: MyApp.WeatherAPI)\n      Application.put_env(:my_app, :weather, MyApp.MockWeatherAPI)\n\n  Now in your tests, you can define expectations with `expect/4` and verify\n  them via `verify_on_exit!/1`:\n\n      defmodule MyApp.HumanizedWeatherTest do\n        use ExUnit.Case, async: true\n\n        import Mox\n\n        # Make sure mocks are verified when the test exits\n        setup :verify_on_exit!\n\n        test \"gets and formats temperature and humidity\" do\n          MyApp.MockWeatherAPI\n          |> expect(:temp, fn {_lat, _long} -> {:ok, 30} end)\n          |> expect(:humidity, fn {_lat, _long} -> {:ok, 60} end)\n\n          assert MyApp.HumanizedWeather.display_temp({50.06, 19.94}) ==\n                   \"Current temperature is 30 degrees\"\n\n          assert MyApp.HumanizedWeather.display_humidity({50.06, 19.94}) ==\n                   \"Current humidity is 60%\"\n        end\n      end\n\n  All expectations are defined based on the current process. This\n  means multiple tests using the same mock can still run concurrently\n  unless the Mox is set to global mode. See the \"Multi-process collaboration\"\n  section.\n\n  One last note, if the mock is used throughout the test suite, you might want\n  the implementation to fall back to a stub (or actual) implementation when no\n  expectations are defined. You can use `stub_with/2` in a case template that\n  is used throughout your test suite:\n\n      defmodule MyApp.Case do\n        use ExUnit.CaseTemplate\n\n        setup _ do\n          Mox.stub_with(MyApp.MockWeatherAPI, MyApp.StubWeatherAPI)\n          :ok\n        end\n      end\n\n  Now, for every test case that uses `ExUnit.Case`, it can use `MyApp.Case`\n  instead. Then, if no expectations are defined it will call the implementation\n  in `MyApp.StubWeatherAPI`.\n\n  ## Multiple behaviours\n\n  Mox supports defining mocks for multiple behaviours.\n\n  Suppose your library also defines a behaviour for getting past weather:\n\n      defmodule MyApp.PastWeather do\n        @callback past_temp(MyApp.LatLong.t(), DateTime.t()) :: {:ok, integer()}\n      end\n\n  You can mock both the weather and past weather behaviour:\n\n      Mox.defmock(MyApp.MockWeatherAPI, for: [MyApp.Weather, MyApp.PastWeather])\n\n  ## Compile-time requirements\n\n  If the mock needs to be available during the project compilation, for\n  instance because you get undefined function warnings, then instead of\n  defining the mock in your `test_helper.exs`, you should instead define\n  it under `test/support/mocks.ex`:\n\n      Mox.defmock(MyApp.MockWeatherAPI, for: MyApp.WeatherAPI)\n\n  Then you need to make sure that files in `test/support` get compiled\n  with the rest of the project. Edit your `mix.exs` file to add the\n  `test/support` directory to compilation paths:\n\n      def project do\n        [\n          ...\n          elixirc_paths: elixirc_paths(Mix.env),\n          ...\n        ]\n      end\n\n      defp elixirc_paths(:test), do: [\"test/support\", \"lib\"]\n      defp elixirc_paths(_),     do: [\"lib\"]\n\n  ## Multi-process collaboration\n\n  Mox supports multi-process collaboration via two mechanisms:\n\n    1. explicit allowances\n    2. global mode\n\n  The allowance mechanism can still run tests concurrently while\n  the global one doesn't. We explore both next.\n\n  ### Explicit allowances\n\n  An allowance permits a child process to use the expectations and stubs\n  defined in the parent process while still being safe for async tests.\n\n      test \"invokes add and mult from a task\" do\n        MyApp.MockWeatherAPI\n        |> expect(:temp, fn _loc -> {:ok, 30} end)\n        |> expect(:humidity, fn _loc -> {:ok, 60} end)\n\n        parent_pid = self()\n\n        Task.async(fn ->\n          MyApp.MockWeatherAPI |> allow(parent_pid, self())\n\n          assert MyApp.HumanizedWeather.display_temp({50.06, 19.94}) ==\n                   \"Current temperature is 30 degrees\"\n\n          assert MyApp.HumanizedWeather.display_humidity({50.06, 19.94}) ==\n                   \"Current humidity is 60%\"\n        end)\n        |> Task.await\n      end\n\n  Note: if you're running on Elixir 1.8.0 or greater and your concurrency comes\n  from a `Task` then you don't need to add explicit allowances. Instead\n  `$callers` is used to determine the process that actually defined the\n  expectations.\n\n  ### Global mode\n\n  Mox supports global mode, where any process can consume mocks and stubs\n  defined in your tests. `set_mox_from_context/0` automatically calls\n  `set_mox_global/1` but only if the test context **doesn't** include\n  `async: true`.\n\n  By default the mode is `:private`.\n\n      setup :set_mox_from_context\n      setup :verify_on_exit!\n\n      test \"invokes add and mult from a task\" do\n        MyApp.MockWeatherAPI\n        |> expect(:temp, fn _loc -> {:ok, 30} end)\n        |> expect(:humidity, fn _loc -> {:ok, 60} end)\n\n        Task.async(fn ->\n          assert MyApp.HumanizedWeather.display_temp({50.06, 19.94}) ==\n                    \"Current temperature is 30 degrees\"\n\n          assert MyApp.HumanizedWeather.display_humidity({50.06, 19.94}) ==\n                    \"Current humidity is 60%\"\n        end)\n        |> Task.await\n      end\n\n  ### Blocking on expectations\n\n  If your mock is called in a different process than the test process,\n  in some cases there is a chance that the test will finish executing\n  before it has a chance to call the mock and meet the expectations.\n  Imagine this:\n\n      test \"calling a mock from a different process\" do\n        expect(MyApp.MockWeatherAPI, :temp, fn _loc -> {:ok, 30} end)\n\n        spawn(fn -> MyApp.HumanizedWeather.temp({50.06, 19.94}) end)\n\n        verify!()\n      end\n\n  The test above has a race condition because there is a chance that the\n  `verify!/0` call will happen before the spawned process calls the mock.\n  In most cases, you don't control the spawning of the process so you can't\n  simply monitor the process to know when it dies in order to avoid this\n  race condition. In those cases, the way to go is to \"sync up\" with the\n  process that calls the mock by sending a message to the test process\n  from the expectation and using that to know when the expectation has been\n  called.\n\n      test \"calling a mock from a different process\" do\n        parent = self()\n        ref = make_ref()\n\n        expect(MyApp.MockWeatherAPI, :temp, fn _loc ->\n          send(parent, {ref, :temp})\n          {:ok, 30}\n        end)\n\n        spawn(fn -> MyApp.HumanizedWeather.temp({50.06, 19.94}) end)\n\n        assert_receive {^ref, :temp}\n\n        verify!()\n      end\n\n  This way, we'll wait until the expectation is called before calling\n  `verify!/0`.\n  \"\"\"\n\n  @typedoc \"\"\"\n  A mock module.\n\n  This type is available since version 1.1+ of Mox.\n  \"\"\"\n  @type t() :: module()\n\n  defmodule UnexpectedCallError do\n    defexception [:message]\n  end\n\n  defmodule VerificationError do\n    defexception [:message]\n  end\n\n  @doc \"\"\"\n  Sets the Mox to private mode.\n\n  In private mode, mocks can be set and consumed by the same\n  process unless other processes are explicitly allowed.\n\n  ## Examples\n\n      setup :set_mox_private\n\n  \"\"\"\n  @spec set_mox_private(term()) :: :ok\n  def set_mox_private(_context \\\\ %{}), do: Mox.Server.set_mode(self(), :private)\n\n  @doc \"\"\"\n  Sets the Mox to global mode.\n\n  In global mode, mocks can be consumed by any process.\n\n  An ExUnit case where tests use Mox in global mode cannot be\n  `async: true`.\n\n  ## Examples\n\n      setup :set_mox_global\n  \"\"\"\n  @spec set_mox_global(term()) :: :ok\n  def set_mox_global(context \\\\ %{}) do\n    if Map.get(context, :async) do\n      raise \"Mox cannot be set to global mode when the ExUnit case is async. \" <>\n              \"If you want to use Mox in global mode, remove \\\"async: true\\\" when using ExUnit.Case\"\n    else\n      Mox.Server.set_mode(self(), :global)\n    end\n  end\n\n  @doc \"\"\"\n  Chooses the Mox mode based on context.\n\n  When `async: true` is used, `set_mox_private/1` is called,\n  otherwise `set_mox_global/1` is used.\n\n  ## Examples\n\n      setup :set_mox_from_context\n\n  \"\"\"\n  @spec set_mox_from_context(term()) :: :ok\n  def set_mox_from_context(%{async: true} = _context), do: set_mox_private()\n  def set_mox_from_context(_context), do: set_mox_global()\n\n  @doc \"\"\"\n  Defines a mock with the given name `:for` the given behaviour(s).\n\n      Mox.defmock(MyMock, for: MyBehaviour)\n\n  With multiple behaviours:\n\n      Mox.defmock(MyMock, for: [MyBehaviour, MyOtherBehaviour])\n\n  ## Options\n\n    * `:for` - module or list of modules to define the mock module for.\n\n    * `:moduledoc` - `@moduledoc` for the defined mock module.\n\n    * `:skip_optional_callbacks` - boolean to determine whether to skip\n      or generate optional callbacks in the mock module.\n\n  ## Skipping optional callbacks\n\n  By default, functions are created for all the behaviour's callbacks,\n  including optional ones. But if for some reason you want to skip one or more\n  of its `@optional_callbacks`, you can provide the list of callback names to\n  skip (along with their arities) as `:skip_optional_callbacks`:\n\n      Mox.defmock(MyMock, for: MyBehaviour, skip_optional_callbacks: [on_success: 2])\n\n  This will define a new mock (`MyMock`) that has a defined function for each\n  callback on `MyBehaviour` except for `on_success/2`. Note: you can only skip\n  optional callbacks, not required callbacks.\n\n  You can also pass `true` to skip all optional callbacks, or `false` to keep\n  the default of generating functions for all optional callbacks.\n\n  ## Passing `@moduledoc`\n\n  You can provide value for `@moduledoc` with `:moduledoc` option.\n\n      Mox.defmock(MyMock, for: MyBehaviour, moduledoc: false)\n      Mox.defmock(MyMock, for: MyBehaviour, moduledoc: \"My mock module.\")\n\n  \"\"\"\n  @spec defmock(mock, [option]) :: mock\n        when mock: t(),\n             option:\n               {:for, module() | [module()]}\n               | {:skip_optional_callbacks, boolean()}\n               | {:moduledoc, false | String.t()}\n  def defmock(name, options) when is_atom(name) and is_list(options) do\n    behaviours =\n      case Keyword.fetch(options, :for) do\n        {:ok, mocks} -> List.wrap(mocks)\n        :error -> raise ArgumentError, \":for option is required on defmock\"\n      end\n\n    skip_optional_callbacks = Keyword.get(options, :skip_optional_callbacks, [])\n    moduledoc = Keyword.get(options, :moduledoc, false)\n\n    doc_header = generate_doc_header(moduledoc)\n    compile_header = generate_compile_time_dependency(behaviours)\n    callbacks_to_skip = validate_skip_optional_callbacks!(behaviours, skip_optional_callbacks)\n    mock_funs = generate_mock_funs(behaviours, callbacks_to_skip)\n\n    define_mock_module(name, behaviours, doc_header ++ compile_header ++ mock_funs)\n\n    name\n  end\n\n  defp validate_module!(behaviour) do\n    ensure_compiled!(behaviour)\n  end\n\n  defp validate_behaviour!(behaviour) do\n    if function_exported?(behaviour, :behaviour_info, 1) do\n      behaviour\n    else\n      raise ArgumentError,\n            \"module #{inspect(behaviour)} is not a behaviour, please pass a behaviour to :for\"\n    end\n  end\n\n  defp generate_doc_header(moduledoc) do\n    [\n      quote do\n        @moduledoc unquote(moduledoc)\n      end\n    ]\n  end\n\n  defp generate_compile_time_dependency(behaviours) do\n    for behaviour <- behaviours do\n      behaviour\n      |> validate_module!()\n      |> validate_behaviour!()\n\n      quote do\n        @behaviour unquote(behaviour)\n        unquote(behaviour).module_info(:module)\n      end\n    end\n  end\n\n  defp generate_mock_funs(behaviours, callbacks_to_skip) do\n    for behaviour <- behaviours,\n        {fun, arity} <- behaviour.behaviour_info(:callbacks),\n        {fun, arity} not in callbacks_to_skip do\n      args = 0..arity |> Enum.to_list() |> tl() |> Enum.map(&Macro.var(:\"arg#{&1}\", Elixir))\n\n      quote do\n        def unquote(fun)(unquote_splicing(args)) do\n          Mox.__dispatch__(__MODULE__, unquote(fun), unquote(arity), unquote(args))\n        end\n      end\n    end\n  end\n\n  defp validate_skip_optional_callbacks!(behaviours, skip_optional_callbacks) do\n    all_optional_callbacks =\n      for behaviour <- behaviours,\n          {fun, arity} <- behaviour.behaviour_info(:optional_callbacks) do\n        {fun, arity}\n      end\n\n    case skip_optional_callbacks do\n      false ->\n        []\n\n      true ->\n        all_optional_callbacks\n\n      skip_list when is_list(skip_list) ->\n        for callback <- skip_optional_callbacks, callback not in all_optional_callbacks do\n          raise ArgumentError,\n                \"all entries in :skip_optional_callbacks must be an optional callback in one \" <>\n                  \"of the behaviours specified in :for. #{inspect(callback)} was not in the \" <>\n                  \"list of all optional callbacks: #{inspect(all_optional_callbacks)}\"\n        end\n\n        skip_list\n\n      _ ->\n        raise ArgumentError, \":skip_optional_callbacks is required to be a list or boolean\"\n    end\n  end\n\n  defp define_mock_module(name, behaviours, body) do\n    info =\n      quote do\n        def __mock_for__ do\n          unquote(behaviours)\n        end\n      end\n\n    Module.create(name, [info | body], Macro.Env.location(__ENV__))\n  end\n\n  @doc \"\"\"\n  Expects the `name` in `mock` with arity given by `code`\n  to be invoked `n` times.\n\n  If you're calling your mock from an asynchronous process and want\n  to wait for the mock to be called, see the \"Blocking on expectations\"\n  section in the module documentation.\n\n  When `expect/4` is invoked, any previously declared `stub` for the same `name` and arity will\n  be removed. This ensures that `expect` will fail if the function is called more than `n` times.\n  If a `stub/3` is invoked **after** `expect/4` for the same `name` and arity, the stub will be\n  used after all expectations are fulfilled.\n\n  ## Examples\n\n  To expect `MockWeatherAPI.get_temp/1` to be called once:\n\n      expect(MockWeatherAPI, :get_temp, fn _ -> {:ok, 30} end)\n\n  To expect `MockWeatherAPI.get_temp/1` to be called five times:\n\n      expect(MockWeatherAPI, :get_temp, 5, fn _ -> {:ok, 30} end)\n\n  To expect `MockWeatherAPI.get_temp/1` not to be called:\n\n      expect(MockWeatherAPI, :get_temp, 0, fn _ -> {:ok, 30} end)\n\n  `expect/4` can also be invoked multiple times for the same name/arity,\n  allowing you to give different behaviours on each invocation. For instance,\n  you could test that your code will try an API call three times before giving\n  up:\n\n      MockWeatherAPI\n      |> expect(:get_temp, 2, fn _loc -> {:error, :unreachable} end)\n      |> expect(:get_temp, 1, fn _loc -> {:ok, 30} end)\n\n      log = capture_log(fn ->\n        assert Weather.current_temp(location)\n          == \"It's currently 30 degrees\"\n      end)\n\n      assert log =~ \"attempt 1 failed\"\n      assert log =~ \"attempt 2 failed\"\n      assert log =~ \"attempt 3 succeeded\"\n\n      MockWeatherAPI\n      |> expect(:get_temp, 3, fn _loc -> {:error, :unreachable} end)\n\n      assert Weather.current_temp(location) == \"Current temperature is unavailable\"\n  \"\"\"\n  @spec expect(mock, atom(), non_neg_integer(), function()) :: mock when mock: t()\n  def expect(mock, name, n \\\\ 1, code)\n      when is_atom(mock) and is_atom(name) and is_integer(n) and n >= 0 and is_function(code) do\n    calls = List.duplicate(code, n)\n    add_expectation!(mock, name, code, {n, calls, nil})\n    mock\n  end\n\n  @doc \"\"\"\n  Allows the `name` in `mock` with arity given by `code` to\n  be invoked zero or many times.\n\n  Unlike expectations, stubs are never verified.\n\n  If expectations and stubs are defined for the same function\n  and arity, the stub is invoked only after all expectations are\n  fulfilled.\n\n  ## Examples\n\n  To allow `MockWeatherAPI.get_temp/1` to be called any number of times:\n\n      stub(MockWeatherAPI, :get_temp, fn _loc -> {:ok, 30} end)\n\n  `stub/3` will overwrite any previous calls to `stub/3`.\n  \"\"\"\n  @spec stub(mock, atom(), function()) :: mock when mock: t()\n  def stub(mock, name, code)\n      when is_atom(mock) and is_atom(name) and is_function(code) do\n    add_expectation!(mock, name, code, {0, [], code})\n    mock\n  end\n\n  @doc \"\"\"\n  Stubs all functions described by the shared behaviours in the `mock` and `module`.\n\n  ## Examples\n\n      defmodule MyApp.WeatherAPI do\n        @callback temp(MyApp.LatLong.t()) :: {:ok, integer()}\n        @callback humidity(MyApp.LatLong.t()) :: {:ok, integer()}\n      end\n\n      defmodule MyApp.StubWeatherAPI do\n        @behaviour WeatherAPI\n        def temp(_loc), do: {:ok, 30}\n        def humidity(_loc), do: {:ok, 60}\n      end\n\n      defmock(MyApp.MockWeatherAPI, for: MyApp.WeatherAPI)\n      stub_with(MyApp.MockWeatherAPI, MyApp.StubWeatherAPI)\n\n  This is the same as calling `stub/3` for each callback in `MyApp.MockWeatherAPI`:\n\n      stub(MyApp.MockWeatherAPI, :temp, &MyApp.StubWeatherAPI.temp/1)\n      stub(MyApp.MockWeatherAPI, :humidity, &MyApp.StubWeatherAPI.humidity/1)\n\n  \"\"\"\n  @spec stub_with(mock, module()) :: mock when mock: t()\n  def stub_with(mock, module) when is_atom(mock) and is_atom(module) do\n    mock_behaviours = mock.__mock_for__()\n\n    behaviours =\n      case module_behaviours(module) do\n        [] ->\n          raise ArgumentError, \"#{inspect(module)} does not implement any behaviour\"\n\n        behaviours ->\n          case Enum.filter(behaviours, &(&1 in mock_behaviours)) do\n            [] ->\n              raise ArgumentError,\n                    \"#{inspect(module)} and #{inspect(mock)} do not share any behaviour\"\n\n            common ->\n              common\n          end\n      end\n\n    for behaviour <- behaviours,\n        {fun, arity} <- behaviour.behaviour_info(:callbacks),\n        function_exported?(mock, fun, arity) do\n      stub(mock, fun, :erlang.make_fun(module, fun, arity))\n    end\n\n    mock\n  end\n\n  defp module_behaviours(module) do\n    module.module_info(:attributes)\n    |> Keyword.get_values(:behaviour)\n    |> List.flatten()\n  end\n\n  defp add_expectation!(mock, name, code, value) do\n    validate_mock!(mock)\n    arity = :erlang.fun_info(code)[:arity]\n    key = {mock, name, arity}\n\n    unless function_exported?(mock, name, arity) do\n      raise ArgumentError, \"unknown function #{name}/#{arity} for mock #{inspect(mock)}\"\n    end\n\n    case Mox.Server.add_expectation(self(), key, value) do\n      :ok ->\n        :ok\n\n      {:error, {:currently_allowed, owner_pid}} ->\n        inspected = inspect(self())\n\n        raise ArgumentError, \"\"\"\n        cannot add expectations/stubs to #{inspect(mock)} in the current process (#{inspected}) \\\n        because the process has been allowed by #{inspect(owner_pid)}. \\\n        You cannot define expectations/stubs in a process that has been allowed\n        \"\"\"\n\n      {:error, {:not_global_owner, global_pid}} ->\n        inspected = inspect(self())\n\n        raise ArgumentError, \"\"\"\n        cannot add expectations/stubs to #{inspect(mock)} in the current process (#{inspected}) \\\n        because Mox is in global mode and the global process is #{inspect(global_pid)}. \\\n        Only the process that set Mox to global can set expectations/stubs in global mode\n        \"\"\"\n    end\n  end\n\n  @doc \"\"\"\n  Allows other processes to share expectations and stubs\n  defined by owner process.\n\n  ## Examples\n\n  To allow `child_pid` to call any stubs or expectations defined for `MyMock`:\n\n      allow(MyMock, self(), child_pid)\n\n  `allow/3` also accepts named process or via references:\n\n      allow(MyMock, self(), SomeChildProcess)\n\n  \"\"\"\n  @spec allow(mock, pid(), term()) :: mock when mock: t()\n  def allow(mock, owner_pid, allowed_via) when is_atom(mock) and is_pid(owner_pid) do\n    allowed_pid = GenServer.whereis(allowed_via)\n\n    if allowed_pid == owner_pid do\n      raise ArgumentError, \"owner_pid and allowed_pid must be different\"\n    end\n\n    case Mox.Server.allow(mock, owner_pid, allowed_pid) do\n      :ok ->\n        mock\n\n      {:error, {:already_allowed, actual_pid}} ->\n        raise ArgumentError, \"\"\"\n        cannot allow #{inspect(allowed_pid)} to use #{inspect(mock)} from #{inspect(owner_pid)} \\\n        because it is already allowed by #{inspect(actual_pid)}.\n\n        If you are seeing this error message, it is because you are either \\\n        setting up allowances from different processes or your tests have \\\n        async: true and you found a race condition where two different tests \\\n        are allowing the same process\n        \"\"\"\n\n      {:error, :expectations_defined} ->\n        raise ArgumentError, \"\"\"\n        cannot allow #{inspect(allowed_pid)} to use #{inspect(mock)} from #{inspect(owner_pid)} \\\n        because the process has already defined its own expectations/stubs\n        \"\"\"\n\n      {:error, :in_global_mode} ->\n        # Already allowed\n        mock\n    end\n  end\n\n  @doc \"\"\"\n  Verifies the current process after it exits.\n\n  If you want to verify expectations for all tests, you can use\n  `verify_on_exit!/1` as a setup callback:\n\n      setup :verify_on_exit!\n\n  \"\"\"\n  @spec verify_on_exit!(term()) :: :ok\n  def verify_on_exit!(_context \\\\ %{}) do\n    pid = self()\n    Mox.Server.verify_on_exit(pid)\n\n    ExUnit.Callbacks.on_exit(Mox, fn ->\n      verify_mock_or_all!(pid, :all, :on_exit)\n    end)\n  end\n\n  @doc \"\"\"\n  Verifies that all expectations set by the current process\n  have been called.\n  \"\"\"\n  @spec verify!() :: :ok\n  def verify! do\n    verify_mock_or_all!(self(), :all, :test)\n  end\n\n  @doc \"\"\"\n  Verifies that all expectations in `mock` have been called.\n  \"\"\"\n  @spec verify!(t()) :: :ok\n  def verify!(mock) do\n    validate_mock!(mock)\n    verify_mock_or_all!(self(), mock, :test)\n  end\n\n  defp verify_mock_or_all!(pid, mock, test_or_on_exit) do\n    pending = Mox.Server.verify(pid, mock, test_or_on_exit)\n\n    messages =\n      for {{module, name, arity}, total, pending} <- pending do\n        mfa = Exception.format_mfa(module, name, arity)\n        called = total - pending\n        \"  * expected #{mfa} to be invoked #{times(total)} but it was invoked #{times(called)}\"\n      end\n\n    if messages != [] do\n      raise VerificationError,\n            \"error while verifying mocks for #{inspect(pid)}:\\n\\n\" <> Enum.join(messages, \"\\n\")\n    end\n\n    :ok\n  end\n\n  defp validate_mock!(mock) do\n    ensure_compiled!(mock)\n\n    unless function_exported?(mock, :__mock_for__, 0) do\n      raise ArgumentError, \"module #{inspect(mock)} is not a mock\"\n    end\n\n    :ok\n  end\n\n  @compile {:no_warn_undefined, {Code, :ensure_compiled!, 1}}\n\n  defp ensure_compiled!(mod) do\n    if function_exported?(Code, :ensure_compiled!, 1) do\n      Code.ensure_compiled!(mod)\n    else\n      case Code.ensure_compiled(mod) do\n        {:module, mod} ->\n          mod\n\n        {:error, reason} ->\n          raise ArgumentError,\n                \"could not load module #{inspect(mod)} due to reason #{inspect(reason)}\"\n      end\n    end\n  end\n\n  @doc false\n  def __dispatch__(mock, name, arity, args) do\n    all_callers = [self() | caller_pids()]\n\n    case Mox.Server.fetch_fun_to_dispatch(all_callers, {mock, name, arity}) do\n      :no_expectation ->\n        mfa = Exception.format_mfa(mock, name, arity)\n\n        raise UnexpectedCallError,\n              \"no expectation defined for #{mfa} in #{format_process()} with args #{inspect(args)}\"\n\n      {:out_of_expectations, count} ->\n        mfa = Exception.format_mfa(mock, name, arity)\n\n        raise UnexpectedCallError,\n              \"expected #{mfa} to be called #{times(count)} but it has been \" <>\n                \"called #{times(count + 1)} in #{format_process()}\"\n\n      {:ok, fun_to_call} ->\n        apply(fun_to_call, args)\n    end\n  end\n\n  defp times(1), do: \"once\"\n  defp times(n), do: \"#{n} times\"\n\n  defp format_process do\n    callers = caller_pids()\n\n    \"process #{inspect(self())}\" <>\n      if Enum.empty?(callers) do\n        \"\"\n      else\n        \" (or in its callers #{inspect(callers)})\"\n      end\n  end\n\n  # Find the pid of the actual caller\n  defp caller_pids do\n    case Process.get(:\"$callers\") do\n      nil -> []\n      pids when is_list(pids) -> pids\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,9,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable/resources/budget/calculations/spent_by_month.ex","source":"defmodule Spendable.Budget.Calculations.SpentByMonth do\n  use Ash.Calculation, type: :decimal\n\n  import Ecto.Query\n\n  alias Spendable.BudgetAllocation\n  alias Spendable.Repo\n  alias Spendable.Transaction\n\n  @impl Ash.Calculation\n  def calculate(budgets, _opts, %{number_of_months: number_of_months}) do\n    {:ok, Enum.map(budgets, &do_calculate(&1, number_of_months))}\n  end\n\n  defp do_calculate(budget, number_of_months) do\n    start_date =\n      Timex.now() |> Timex.shift(months: -number_of_months + 1) |> Timex.beginning_of_month()\n\n    query =\n      from ba in BudgetAllocation,\n        join: t in Transaction,\n        on: ba.transaction_id == t.id,\n        select: %{\n          month: fragment(\"TO_CHAR(?, 'YYYY-MM-01')::date\", t.date),\n          spent: sum(ba.amount) |> coalesce(^Decimal.new(0))\n        },\n        where: ba.budget_id == ^budget.id,\n        where: ba.amount < 0,\n        where: t.date >= ^start_date,\n        group_by: fragment(\"TO_CHAR(?, 'YYYY-MM-01')\", t.date)\n\n    data = Repo.all(query)\n\n    Timex.Interval.new(from: start_date, until: Timex.now(), right_open: false, step: [months: 1])\n    |> Enum.map(fn datetime ->\n      date = Timex.to_date(datetime)\n      matching_month = Enum.find(data, &(&1.month == date))\n\n      %{\n        spent: matching_month[:spent] || Decimal.new(\"0.00\"),\n        month: date\n      }\n    end)\n    |> Enum.reverse()\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,0,0,null,0,0,null,null,null,0,null,null]},{"name":"lib/spendable/resources/budget.ex","source":"defmodule Spendable.Budget do\n  use Ash.Resource,\n    authorizers: [Ash.Policy.Authorizer],\n    data_layer: AshPostgres.DataLayer,\n    extensions: [AshArchival.Resource]\n\n  require Ash.Resource.Preparation.Builtins\n  alias Spendable.Budget.SpentByMonth\n  alias Spendable.Budget.Storage\n\n  require Ash.Query\n\n  postgres do\n    repo(Spendable.Repo)\n    table \"budgets\"\n\n    custom_indexes do\n      index([\"user_id\"])\n    end\n  end\n\n  attributes do\n    uuid_primary_key :id\n\n    attribute :adjustment, :decimal, allow_nil?: false, default: Decimal.new(\"0.00\")\n    attribute :name, :ci_string, allow_nil?: false\n    attribute :track_spending_only, :boolean, allow_nil?: false, default: false\n\n    timestamps()\n  end\n\n  relationships do\n    belongs_to :user, Spendable.User, allow_nil?: false\n\n    has_many :budget_allocations, Spendable.BudgetAllocation\n    has_many :budget_allocation_template_lines, Spendable.BudgetAllocationTemplateLine\n  end\n\n  calculations do\n    calculate :balance, :decimal, Spendable.Budget.Calculations.Balance do\n      allow_nil? false\n      select [:adjustment]\n    end\n\n    calculate :spent, :decimal, Spendable.Budget.Calculations.Spent do\n      argument :month, :date\n      allow_nil? false\n    end\n\n    calculate :spent_by_month,\n              {:array, SpentByMonth},\n              Spendable.Budget.Calculations.SpentByMonth do\n      argument :number_of_months, :integer\n      allow_nil? false\n    end\n  end\n\n  actions do\n    defaults [:read, :destroy]\n\n    read :list do\n      argument :search, :string\n      argument :selected_month, :date\n\n      filter expr(is_nil(archived_at))\n\n      # search\n      prepare fn query, _context ->\n        search = query.arguments[:search]\n\n        if is_bitstring(search) and byte_size(search) > 0 do\n          Ash.Query.filter(query, contains(name, ^search))\n        else\n          query\n        end\n      end\n\n      # sort\n      prepare after_action(fn _query, results ->\n                {:ok,\n                 Enum.sort(results, fn a, b ->\n                   to_string(b.name) != \"Spendable\" and\n                     (to_string(a.name) == \"Spendable\" or a.name < b.name)\n                 end)}\n              end)\n\n      # load\n      prepare build(\n                load: [\n                  :balance,\n                  spent: %{month: arg(:selected_month) || Date.utc_today()}\n                ]\n              )\n    end\n\n    create :create do\n      primary? true\n      change relate_actor(:user)\n    end\n\n    update :update do\n      primary? true\n\n      argument :balance, :decimal\n      change Spendable.Budget.Changes.SetAdjustment\n    end\n  end\n\n  policies do\n    policy always() do\n      authorize_if action(:create)\n      authorize_if expr(user_id == ^actor(:id))\n    end\n  end\n\n  def form_options(user_id) do\n    Storage.form_options(user_id)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8,null,8,0,null,8,null,null,null,null,8,null,null,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,null]},{"name":"lib/spendable/resources/budget/calculations/balance.ex","source":"defmodule Spendable.Budget.Calculations.Balance do\n  use Ash.Calculation, type: :string\n\n  import Ecto.Query\n\n  alias Spendable.BudgetAllocation\n  alias Spendable.Repo\n\n  @impl Ash.Calculation\n  def calculate(budgets, _opts, _context) do\n    budget_ids = Enum.map(budgets, & &1.id)\n\n    allocated =\n      from(a in BudgetAllocation,\n        select: {a.budget_id, sum(a.amount)},\n        group_by: a.budget_id,\n        where: a.budget_id in ^budget_ids\n      )\n      |> Repo.all()\n      |> Map.new()\n\n    balances =\n      Enum.map(budgets, fn budget ->\n        allocated\n        |> Map.get(budget.id, Decimal.new(\"0\"))\n        |> Decimal.add(budget.adjustment)\n      end)\n\n    {:ok, balances}\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,8,null,8,null,null,null,null,null,null,null,null,8,null,null,6,6,null,null,null,null,null]},{"name":"lib/spendable_web/controllers/auth_controller.ex","source":"defmodule SpendableWeb.AuthController do\n  @moduledoc \"\"\"\n  Auth controller responsible for handling Ueberauth responses\n  \"\"\"\n  use SpendableWeb, :controller\n\n  plug Ueberauth\n\n  alias Spendable.User\n\n  def login(conn, _params) do\n    render(conn, :login, layout: false)\n  end\n\n  def callback(%{assigns: %{ueberauth_failure: _fails}} = conn, _params) do\n    conn\n    |> put_flash(:error, \"Failed to authenticate.\")\n    |> redirect(to: \"/\")\n  end\n\n  def callback(%{assigns: %{ueberauth_auth: auth}} = conn, _params) do\n    %Ueberauth.Auth{\n      uid: uid,\n      provider: provider,\n      info: %Ueberauth.Auth.Info{\n        image: image\n      }\n    } = auth\n\n    user =\n      User\n      |> Ash.Changeset.new(%{\n        external_id: uid,\n        provider: provider,\n        image: image\n      })\n      |> Spendable.Api.create!(upsert?: true, upsert_identity: :external_id)\n\n    conn\n    |> put_session(:current_user_id, user.id)\n    |> configure_session(renew: true)\n    |> redirect(to: ~p\"/budgets\")\n  end\n\n  def delete(conn, _params) do\n    conn\n    |> clear_session()\n    |> redirect(to: \"/\")\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,1,null,null]},{"name":"lib/spendable_web/live/budgets.ex","source":"defmodule SpendableWeb.Live.Budgets do\n  use SpendableWeb, :live_view\n\n  alias Spendable.Budget\n  alias Spendable.Utils\n\n  def mount(_params, _session, socket) do\n    {:ok, fetch_data(socket)}\n  end\n\n  def handle_params(_unsigned_params, _uri, socket) do\n    {:noreply, socket |> fetch_data()}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <div>\n      <main id=\"budgets\" phx-click={JS.push(\"close\") |> hide_details()}>\n        <header class=\"flex items-center justify-between border-b border-white/5 px-8 py-6\">\n          <h1 class=\"text-base font-semibold leading-7 text-white\">Budgets</h1>\n          <div class=\"flex gap-x-6\">\n            <!-- Sort dropdown -->\n            <div class=\"relative\">\n              <button\n                type=\"button\"\n                class=\"flex items-center gap-x-1 text-sm font-medium leading-6 text-white\"\n                id=\"sort-menu-button\"\n                phx-click={JS.toggle(to: \"#month-select\")}\n              >\n                <%= Timex.format!(@selected_month, \"{Mfull} {YYYY}\") %>\n                <.icon name=\"hero-chevron-up-down-mini\" class=\"h-5 w-5 text-gray-500\" />\n              </button>\n              <div\n                id=\"month-select\"\n                class=\"hidden absolute right-0 z-10 mt-2.5 w-40 origin-top-right rounded-md bg-white max-h-96 overflow-auto shadow-lg ring-1 ring-gray-900/5 focus:outline-none divide-y\"\n                phx-click-away={JS.hide(to: \"#month-select\")}\n              >\n                <button\n                  :for={month <- @current_user.spent_by_month}\n                  class=\"block px-3 py-2 w-full text-sm leading-6 text-gray-900 flex flex-col hover:bg-gray-200\"\n                  phx-click={JS.push(\"select_month\") |> JS.toggle(to: \"#month-select\")}\n                  phx-value-month={month.month}\n                >\n                  <div><%= Timex.format!(month.month, \"{Mfull} {YYYY}\") %></div>\n                  <div class=\"text-sm text-gray-400\">spent: <%= Utils.format_currency(month.spent) %></div>\n                </button>\n              </div>\n            </div>\n            <button\n              :if={is_nil(@form)}\n              id=\"new-budget\"\n              type=\"button\"\n              phx-click={JS.push(\"new\") |> show_details()}\n              class=\"text-sm font-semibold leading-6 text-blue-400\"\n            >\n              New\n            </button>\n            <button\n              :if={not Enum.empty?(@selected_budgets)}\n              id=\"archive\"\n              type=\"button\"\n              phx-click=\"archive\"\n              class=\"text-sm font-semibold leading-6 text-blue-400\"\n            >\n              Archive (<%= length(@selected_budgets) %>)\n            </button>\n            <button\n              :if={not is_nil(@form)}\n              type=\"button\"\n              phx-click={JS.push(\"close\") |> hide_details()}\n              class=\"text-sm font-semibold leading-6 text-blue-400\"\n            >\n              Close\n            </button>\n          </div>\n        </header>\n        <!-- Budget list -->\n        <ul role=\"list\" class=\"divide-y divide-white/5\">\n          <li\n            :for={budget <- @budgets}\n            phx-click={JS.push(\"select_budget\") |> show_details()}\n            phx-value-id={budget.id}\n            class=\"relative flex flex-row items-center justify-between space-x-4 py-6 pr-8\"\n          >\n            <div class=\"min-w-0 flex-auto ml-1\">\n              <div class=\"flex items-center\">\n                <div :if={to_string(budget.id) not in @selected_budgets} class=\"pl-1 pr-2 opacity-0 hover:opacity-100\">\n                  <input\n                    type=\"checkbox\"\n                    value=\"true\"\n                    checked={false}\n                    phx-click=\"check_budget\"\n                    phx-value-id={budget.id}\n                    class=\"rounded border-white/10 bg-white/5 text-white/5\"\n                  />\n                </div>\n                <div :if={to_string(budget.id) in @selected_budgets} class=\"pl-1 pr-2\">\n                  <input\n                    type=\"checkbox\"\n                    value=\"true\"\n                    checked={true}\n                    phx-click=\"uncheck_budget\"\n                    phx-value-id={budget.id}\n                    class=\"rounded border-white/10 bg-white/5 text-white/5\"\n                  />\n                </div>\n                <h2 class=\"min-w-0 text-sm font-semibold leading-6 text-white\">\n                  <a href=\"#\" class=\"flex gap-x-2\">\n                    <span class=\"truncate\"><%= budget.name %></span>\n                  </a>\n                </h2>\n              </div>\n            </div>\n            <div class=\"flex items-center\">\n              <div class=\"min-w-0 flex-auto mr-4\">\n                <div class=\"flex items-center gap-x-3\">\n                  <h2 class=\"w-full text-sm font-semibold leading-6 text-white text-right\">\n                    <%= if @current_month_is_selected and not budget.track_spending_only do %>\n                      <span class=\"truncate\"><%= Utils.format_currency(budget.balance) %></span>\n                    <% else %>\n                      <span class=\"truncate\"><%= Utils.format_currency(budget.spent) %></span>\n                    <% end %>\n                  </h2>\n                </div>\n                <div class=\"mt-1 gap-x-2.5 text-xs leading-5 text-gray-400 text-right uppercase\">\n                  <p class=\"truncate\"><%= budget_subtext(budget, assigns) %></p>\n                </div>\n              </div>\n              <div\n                :if={budget.track_spending_only}\n                class=\"rounded-full flex-none py-1 px-2 text-xs font-medium ring-1 ring-inset text-gray-400 bg-gray-400/10 ring-gray-400/20\"\n              >\n                Tracking\n              </div>\n              <div\n                :if={not budget.track_spending_only}\n                class=\"rounded-full flex-none py-1 px-2 text-xs font-medium ring-1 ring-inset text-blue-400 bg-blue-400/10 ring-blue-400/20\"\n              >\n                Envelope\n              </div>\n              <.icon name=\"hero-chevron-right-mini\" class=\"h-5 w-5 flex-none text-gray-400\" />\n            </div>\n          </li>\n        </ul>\n      </main>\n      <aside\n        id=\"details-form\"\n        class=\"hidden bg-black/10 lg:fixed lg:bottom-0 lg:right-0 lg:top-16 lg:w-96 lg:overflow-y-auto lg:border-l lg:border-white/5 text-white\"\n      >\n        <.simple_form :if={@form} for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n          <header class=\"flex items-center justify-between border-b border-white/5 p-6\">\n            <h2 class=\"text-base font-semibold leading-7\">Edit budget</h2>\n            <button phx-click={hide_details()} class=\"text-sm font-semibold leading-6 text-blue-400\">\n              Save\n            </button>\n          </header>\n          <div class=\"space-y-6 m-6\">\n            <.input type=\"text\" label=\"Name\" field={@form[:name]} />\n            <.input :if={not @form[:track_spending_only].value} type=\"text\" label=\"Balance\" field={@form[:balance]} />\n            <.input type=\"checkbox\" label=\"Track spending only\" field={@form[:track_spending_only]} />\n          </div>\n        </.simple_form>\n      </aside>\n    </div>\n    \"\"\"\n  end\n\n  def handle_event(\"validate\", %{\"form\" => params}, socket) do\n    form = AshPhoenix.Form.validate(socket.assigns.form, params)\n    {:noreply, assign(socket, form: form)}\n  end\n\n  def handle_event(\"submit\", %{\"form\" => params}, socket) do\n    case AshPhoenix.Form.submit(socket.assigns.form, params: params) do\n      {:ok, _budget} ->\n        {:noreply, socket |> assign(:form, nil) |> fetch_data()}\n\n      {:error, form} ->\n        {:noreply, assign(socket, form: form)}\n    end\n  end\n\n  def handle_event(\"search\", params, socket) do\n    {:noreply,\n     socket\n     |> assign(:search, params[\"search\"])\n     |> fetch_data()}\n  end\n\n  def handle_event(\"close\", _params, socket) do\n    {:noreply, assign(socket, :form, nil)}\n  end\n\n  def handle_event(\"new\", _params, socket) do\n    form =\n      Budget\n      |> AshPhoenix.Form.for_create(:create,\n        api: Spendable.Api,\n        actor: socket.assigns.current_user,\n        forms: [auto?: true]\n      )\n      |> to_form()\n\n    {:noreply, assign(socket, :form, form)}\n  end\n\n  def handle_event(\"select_month\", params, socket) do\n    {:noreply,\n     socket\n     |> assign(:selected_month, Timex.parse!(params[\"month\"], \"{YYYY}-{0M}-{D}\"))\n     |> fetch_data()}\n  end\n\n  def handle_event(\"select_budget\", params, socket) do\n    budget =\n      Enum.find(socket.assigns.budgets, &(to_string(&1.id) == params[\"id\"]))\n\n    form =\n      budget\n      |> AshPhoenix.Form.for_update(:update,\n        api: Spendable.Api,\n        actor: socket.assigns.current_user,\n        forms: [auto?: true]\n      )\n      |> to_form()\n\n    {:noreply,\n     socket\n     |> assign(:form, form)}\n  end\n\n  def handle_event(\"archive\", _params, socket) do\n    socket.assigns.budgets\n    |> Enum.filter(&(to_string(&1.id) in socket.assigns.selected_budgets))\n    |> Enum.each(&Spendable.Api.destroy!/1)\n\n    {:noreply, fetch_data(socket)}\n  end\n\n  def handle_event(\"check_budget\", %{\"id\" => id}, socket) do\n    {:noreply, assign(socket, selected_budgets: Enum.uniq([id | socket.assigns.selected_budgets]))}\n  end\n\n  def handle_event(\"uncheck_budget\", %{\"id\" => id}, socket) do\n    {:noreply, assign(socket, selected_budgets: Enum.filter(socket.assigns.selected_budgets, &(&1 != id)))}\n  end\n\n  def show_details(js \\\\ %JS{}) do\n    js\n    |> JS.show(to: \"#details-form\", transition: \"fade-in\")\n    |> JS.add_class(\n      \"lg:pr-96\",\n      to: \"#budgets\"\n    )\n  end\n\n  def hide_details(js \\\\ %JS{}) do\n    js\n    |> JS.hide(to: \"#details-form\", transition: \"fade-out\")\n    |> JS.remove_class(\n      \"lg:pr-96\",\n      to: \"#budgets\",\n      transition: \"fade-out\"\n    )\n  end\n\n  defp fetch_data(socket) do\n    current_month = Date.utc_today() |> Timex.beginning_of_month()\n    selected_month = socket.assigns[:selected_month] || current_month\n\n    budgets =\n      Budget\n      |> Ash.Query.for_read(:list,\n        selected_month: selected_month,\n        search: socket.assigns[:search]\n      )\n      |> Spendable.Api.read!(actor: socket.assigns.current_user)\n\n    user = Spendable.Api.load!(socket.assigns.current_user, :spent_by_month)\n\n    socket\n    |> assign(:current_user, user)\n    |> assign(:selected_month, selected_month)\n    |> assign(:selected_budgets, [])\n    |> assign(:budgets, budgets)\n    |> assign(:current_month_is_selected, Timex.equal?(selected_month, current_month))\n    |> assign(:form, nil)\n  end\n\n  defp budget_subtext(budget, %{current_month_is_selected: current}) do\n    cond do\n      current and budget.name == \"Spendable\" -> \"AVAILABLE\"\n      current and not budget.track_spending_only -> \"REMAINING\"\n      true -> \"SPENT\"\n    end\n  end\nend","coverage":[null,null,null,null,null,null,2,null,null,null,2,null,null,null,null,13,null,2,null,null,null,null,null,2,null,null,null,null,null,2,2,null,2,null,null,null,null,null,2,null,null,2,null,2,2,null,null,null,5,9,null,null,null,null,null,null,null,null,6,null,null,null,null,null,2,null,3,9,null,null,null,null,null,null,null,null,null,null,null,13,null,15,null,null,null,null,15,13,null,null,null,null,13,null,null,null,15,2,null,null,null,null,2,null,null,null,null,null,15,null,null,null,null,null,null,null,null,15,7,null,8,null,null,null,null,null,null,null,null,15,null,null,null,null,null,15,null,null,null,null,null,null,null,null,null,null,null,null,null,9,null,null,3,null,null,null,null,4,4,4,null,null,null,null,null,null,null,1,1,null,null,null,null,3,3,null,null,0,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,2,2,null,null,null,2,null,null,null,null,null,null,null,0,null,null,null,null,null,null,1,1,1,null,1,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,2,1,null,null,null,null,2,2,null,null,1,1,null,null,null,null,null,20,null,null,null,null,null,null,null,null,8,null,null,null,null,null,null,null,8,8,null,8,null,null,null,8,null,8,null,8,null,null,null,null,null,null,null,8,null,null,null,15,15,15,8,null,null,null]},{"name":"lib/spendable/registry.ex","source":"defmodule Spendable.Registry do\n  use Ash.Registry,\n    extensions: [\n      # This extension adds helpful compile time validations\n      Ash.Registry.ResourceValidations\n    ]\n\n  entries do\n    entry Spendable.BankAccount\n    entry Spendable.BankMember\n    entry Spendable.BankTransaction\n    entry Spendable.Budget\n    entry Spendable.BudgetAllocation\n    entry Spendable.BudgetAllocationTemplate\n    entry Spendable.BudgetAllocationTemplateLine\n    entry Spendable.Transaction\n    entry Spendable.User\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable/resources/budget/spent_by_month.ex","source":"defmodule Spendable.Budget.SpentByMonth do\n  use Ash.Resource,\n    data_layer: :embedded\n\n  attributes do\n    attribute :month, :date, allow_nil?: false\n    attribute :spent, :decimal, allow_nil?: false\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable/resources/bank_transaction.ex","source":"defmodule Spendable.BankTransaction do\n  use Ash.Resource,\n    data_layer: AshPostgres.DataLayer\n\n  postgres do\n    repo(Spendable.Repo)\n    table \"bank_transactions\"\n\n    custom_indexes do\n      index([\"bank_account_id\"])\n      index([\"user_id\"])\n    end\n  end\n\n  identities do\n    identity :external_id, [:external_id, :bank_account_id]\n  end\n\n  attributes do\n    uuid_primary_key :id\n\n    attribute :amount, :decimal, allow_nil?: false\n    attribute :date, :date, allow_nil?: false\n    attribute :name, :string, allow_nil?: false\n    attribute :external_id, :string, allow_nil?: false, private?: true\n    attribute :pending, :boolean, allow_nil?: false\n\n    timestamps()\n  end\n\n  relationships do\n    belongs_to :user, Spendable.User, allow_nil?: false\n    belongs_to :bank_account, Spendable.BankAccount, allow_nil?: false\n\n    has_one :transaction, Spendable.Transaction\n  end\n\n  actions do\n    defaults [:read, :create]\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable_web/controllers/error_html.ex","source":"defmodule SpendableWeb.ErrorHTML do\n  use SpendableWeb, :html\n\n  # If you want to customize your error pages,\n  # uncomment the embed_templates/1 call below\n  # and add pages to the error directory:\n  #\n  #   * lib/spendable_web/controllers/error_html/404.html.heex\n  #   * lib/spendable_web/controllers/error_html/500.html.heex\n  #\n  # embed_templates \"error_html/*\"\n\n  # The default is to render a plain text page based on\n  # the template name. For example, \"404.html\" becomes\n  # \"Not Found\".\n  def render(template, _assigns) do\n    Phoenix.Controller.status_message_from_template(template)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null]},{"name":"lib/spendable/repo.ex","source":"defmodule Spendable.Repo do\n  use AshPostgres.Repo,\n    otp_app: :spendable,\n    adapter: Ecto.Adapters.Postgres\n\n  def installed_extensions() do\n    [\"citext\", \"uuid-ossp\"]\n  end\nend","coverage":[null,null,null,null,null,1,null,null,null]},{"name":"lib/spendable/resources/transactions/storage.ex","source":"defmodule Spendable.Transaction.Storage do\n  alias Spendable.Api\n  alias Spendable.Transaction\n\n  require Ash.Query\n\n  @default_per_page 25\n\n  def list_transactions(user_id, opts \\\\ []) do\n    Transaction\n    |> Ash.Query.filter(user_id == ^user_id)\n    |> maybe_search_transactions(opts[:search])\n    |> Ash.Query.sort(date: :desc, id: :desc)\n    |> maybe_paginate(opts[:page], opts[:per_page])\n    |> Ash.Query.limit(opts[:per_page] || @default_per_page)\n    |> Api.read!()\n  end\n\n  defp maybe_search_transactions(query, search) when byte_size(search) > 0 do\n    Ash.Query.filter(query, contains(name, ^search) or contains(note, ^search))\n  end\n\n  defp maybe_search_transactions(query, _search), do: query\n\n  defp maybe_paginate(query, page, limit) when page > 0 do\n    limit = limit || @default_per_page\n    offset = (page - 1) * limit\n    Ash.Query.offset(query, offset)\n  end\n\n  defp maybe_paginate(query, _page, _limit), do: query\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,null,null,0,null,null,0,0,0,null,null,0,null]},{"name":"lib/spendable/resources/budget_allocation_template/factory.ex","source":"defmodule Spendable.BudgetAllocationTemplate.Factory do\n  def default() do\n    %{\n      name: \"Payday\"\n    }\n  end\nend","coverage":[null,null,0,null,null,null,null]},{"name":"lib/spendable_web/components/core_components.ex","source":"defmodule SpendableWeb.CoreComponents do\n  @moduledoc \"\"\"\n  Provides core UI components.\n\n  At the first glance, this module may seem daunting, but its goal is\n  to provide some core building blocks in your application, such modals,\n  tables, and forms. The components are mostly markup and well documented\n  with doc strings and declarative assigns. You may customize and style\n  them in any way you want, based on your application growth and needs.\n\n  The default components use Tailwind CSS, a utility-first CSS framework.\n  See the [Tailwind CSS documentation](https://tailwindcss.com) to learn\n  how to customize them or feel free to swap in another framework altogether.\n\n  Icons are provided by [heroicons](https://heroicons.com). See `icon/1` for usage.\n  \"\"\"\n  use Phoenix.Component\n\n  alias Phoenix.LiveView.JS\n  import SpendableWeb.Gettext\n\n  @doc \"\"\"\n  Renders a modal.\n\n  ## Examples\n\n      <.modal id=\"confirm-modal\">\n        This is a modal.\n      </.modal>\n\n  JS commands may be passed to the `:on_cancel` to configure\n  the closing/cancel event, for example:\n\n      <.modal id=\"confirm\" on_cancel={JS.navigate(~p\"/posts\")}>\n        This is another modal.\n      </.modal>\n\n  \"\"\"\n  attr :id, :string, required: true\n  attr :show, :boolean, default: false\n  attr :on_cancel, JS, default: %JS{}\n  slot :inner_block, required: true\n\n  def modal(assigns) do\n    ~H\"\"\"\n    <div\n      id={@id}\n      phx-mounted={@show && show_modal(@id)}\n      phx-remove={hide_modal(@id)}\n      data-cancel={JS.exec(@on_cancel, \"phx-remove\")}\n      class=\"relative z-50 hidden\"\n    >\n      <div id={\"#{@id}-bg\"} class=\"bg-zinc-50/90 fixed inset-0 transition-opacity\" aria-hidden=\"true\" />\n      <div\n        class=\"fixed inset-0 overflow-y-auto\"\n        aria-labelledby={\"#{@id}-title\"}\n        aria-describedby={\"#{@id}-description\"}\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"0\"\n      >\n        <div class=\"flex min-h-full items-center justify-center\">\n          <div class=\"w-full max-w-3xl p-4 sm:p-6 lg:py-8\">\n            <.focus_wrap\n              id={\"#{@id}-container\"}\n              phx-window-keydown={JS.exec(\"data-cancel\", to: \"##{@id}\")}\n              phx-key=\"escape\"\n              phx-click-away={JS.exec(\"data-cancel\", to: \"##{@id}\")}\n              class=\"shadow-zinc-700/10 ring-zinc-700/10 relative hidden rounded-2xl bg-white p-14 shadow-lg ring-1 transition\"\n            >\n              <div class=\"absolute top-6 right-5\">\n                <button\n                  phx-click={JS.exec(\"data-cancel\", to: \"##{@id}\")}\n                  type=\"button\"\n                  class=\"-m-3 flex-none p-3 opacity-20 hover:opacity-40\"\n                  aria-label={gettext(\"close\")}\n                >\n                  <.icon name=\"hero-x-mark-solid\" class=\"h-5 w-5\" />\n                </button>\n              </div>\n              <div id={\"#{@id}-content\"}>\n                <%= render_slot(@inner_block) %>\n              </div>\n            </.focus_wrap>\n          </div>\n        </div>\n      </div>\n    </div>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Renders flash notices.\n\n  ## Examples\n\n      <.flash kind={:info} flash={@flash} />\n      <.flash kind={:info} phx-mounted={show(\"#flash\")}>Welcome Back!</.flash>\n  \"\"\"\n  attr :id, :string, default: \"flash\", doc: \"the optional id of flash container\"\n  attr :flash, :map, default: %{}, doc: \"the map of flash messages to display\"\n  attr :title, :string, default: nil\n  attr :kind, :atom, values: [:info, :error], doc: \"used for styling and flash lookup\"\n  attr :rest, :global, doc: \"the arbitrary HTML attributes to add to the flash container\"\n\n  slot :inner_block, doc: \"the optional inner block that renders the flash message\"\n\n  def flash(assigns) do\n    ~H\"\"\"\n    <div\n      :if={msg = render_slot(@inner_block) || Phoenix.Flash.get(@flash, @kind)}\n      id={@id}\n      phx-click={JS.push(\"lv:clear-flash\", value: %{key: @kind}) |> hide(\"##{@id}\")}\n      role=\"alert\"\n      class={[\n        \"fixed top-2 right-2 w-80 sm:w-96 z-50 rounded-lg p-3 ring-1\",\n        @kind == :info && \"bg-emerald-50 text-emerald-800 ring-emerald-500 fill-cyan-900\",\n        @kind == :error && \"bg-rose-50 text-rose-900 shadow-md ring-rose-500 fill-rose-900\"\n      ]}\n      {@rest}\n    >\n      <p :if={@title} class=\"flex items-center gap-1.5 text-sm font-semibold leading-6\">\n        <.icon :if={@kind == :info} name=\"hero-information-circle-mini\" class=\"h-4 w-4\" />\n        <.icon :if={@kind == :error} name=\"hero-exclamation-circle-mini\" class=\"h-4 w-4\" />\n        <%= @title %>\n      </p>\n      <p class=\"mt-2 text-sm leading-5\"><%= msg %></p>\n      <button type=\"button\" class=\"group absolute top-1 right-1 p-2\" aria-label={gettext(\"close\")}>\n        <.icon name=\"hero-x-mark-solid\" class=\"h-5 w-5 opacity-40 group-hover:opacity-70\" />\n      </button>\n    </div>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Shows the flash group with standard titles and content.\n\n  ## Examples\n\n      <.flash_group flash={@flash} />\n  \"\"\"\n  attr :flash, :map, required: true, doc: \"the map of flash messages\"\n\n  def flash_group(assigns) do\n    ~H\"\"\"\n    <.flash kind={:info} title=\"Success!\" flash={@flash} />\n    <.flash kind={:error} title=\"Error!\" flash={@flash} />\n    <.flash\n      id=\"client-error\"\n      kind={:error}\n      title=\"We can't find the internet\"\n      phx-disconnected={show(\".phx-client-error #client-error\")}\n      phx-connected={hide(\"#client-error\")}\n      hidden\n    >\n      Attempting to reconnect <.icon name=\"hero-arrow-path\" class=\"ml-1 h-3 w-3 animate-spin\" />\n    </.flash>\n\n    <.flash\n      id=\"server-error\"\n      kind={:error}\n      title=\"Something went wrong!\"\n      phx-disconnected={show(\".phx-server-error #server-error\")}\n      phx-connected={hide(\"#server-error\")}\n      hidden\n    >\n      Hang in there while we get back on track <.icon name=\"hero-arrow-path\" class=\"ml-1 h-3 w-3 animate-spin\" />\n    </.flash>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Renders a simple form.\n\n  ## Examples\n\n      <.simple_form for={@form} phx-change=\"validate\" phx-submit=\"save\">\n        <.input field={@form[:email]} label=\"Email\"/>\n        <.input field={@form[:username]} label=\"Username\" />\n        <:actions>\n          <.button>Save</.button>\n        </:actions>\n      </.simple_form>\n  \"\"\"\n  attr :for, :any, required: true, doc: \"the datastructure for the form\"\n  attr :as, :any, default: nil, doc: \"the server side parameter to collect all input under\"\n\n  attr :rest, :global,\n    include: ~w(autocomplete name rel action enctype method novalidate target multipart),\n    doc: \"the arbitrary HTML attributes to apply to the form tag\"\n\n  slot :inner_block, required: true\n  slot :actions, doc: \"the slot for form actions, such as a submit button\"\n\n  def simple_form(assigns) do\n    ~H\"\"\"\n    <.form :let={f} for={@for} as={@as} {@rest}>\n      <div>\n        <%= render_slot(@inner_block, f) %>\n        <div :for={action <- @actions} class=\"mt-2 flex items-center justify-between gap-6\">\n          <%= render_slot(action, f) %>\n        </div>\n      </div>\n    </.form>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Renders a button.\n\n  ## Examples\n\n      <.button>Send!</.button>\n      <.button phx-click=\"go\" class=\"ml-2\">Send!</.button>\n  \"\"\"\n  attr :type, :string, default: nil\n  attr :class, :string, default: nil\n  attr :rest, :global, include: ~w(disabled form name value)\n\n  slot :inner_block, required: true\n\n  def button(assigns) do\n    ~H\"\"\"\n    <button\n      type={@type}\n      class={[\n        \"phx-submit-loading:opacity-75 rounded-lg bg-zinc-900 hover:bg-zinc-700 py-2 px-3\",\n        \"text-sm font-semibold leading-6 text-white active:text-white/80\",\n        @class\n      ]}\n      {@rest}\n    >\n      <%= render_slot(@inner_block) %>\n    </button>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Renders an input with label and error messages.\n\n  A `Phoenix.HTML.FormField` may be passed as argument,\n  which is used to retrieve the input name, id, and values.\n  Otherwise all attributes may be passed explicitly.\n\n  ## Types\n\n  This function accepts all HTML input types, considering that:\n\n    * You may also set `type=\"select\"` to render a `<select>` tag\n\n    * `type=\"checkbox\"` is used exclusively to render boolean values\n\n    * For live file uploads, see `Phoenix.Component.live_file_input/1`\n\n  See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input\n  for more information.\n\n  ## Examples\n\n      <.input field={@form[:email]} type=\"email\" />\n      <.input name=\"my-input\" errors={[\"oh no!\"]} />\n  \"\"\"\n  attr :id, :any, default: nil\n  attr :name, :any\n  attr :label, :string, default: nil\n  attr :value, :any\n\n  attr :type, :string,\n    default: \"text\",\n    values: ~w(checkbox color date datetime-local email file hidden month number password\n               range radio search select tel text textarea time url week)\n\n  attr :field, Phoenix.HTML.FormField, doc: \"a form field struct retrieved from the form, for example: @form[:email]\"\n\n  attr :errors, :list, default: []\n  attr :checked, :boolean, doc: \"the checked flag for checkbox inputs\"\n  attr :prompt, :string, default: nil, doc: \"the prompt for select inputs\"\n  attr :options, :list, doc: \"the options to pass to Phoenix.HTML.Form.options_for_select/2\"\n  attr :multiple, :boolean, default: false, doc: \"the multiple flag for select inputs\"\n\n  attr :rest, :global, include: ~w(accept autocomplete capture cols disabled form list max maxlength min minlength\n                multiple pattern placeholder readonly required rows size step)\n\n  slot :inner_block\n\n  def input(%{field: %Phoenix.HTML.FormField{} = field} = assigns) do\n    assigns\n    |> assign(field: nil, id: assigns.id || field.id)\n    |> assign(:errors, Enum.map(field.errors, &translate_error(&1)))\n    |> assign_new(:name, fn -> if assigns.multiple, do: field.name <> \"[]\", else: field.name end)\n    |> assign_new(:value, fn -> field.value end)\n    |> input()\n  end\n\n  def input(%{type: \"checkbox\", value: value} = assigns) do\n    assigns =\n      assign_new(assigns, :checked, fn -> Phoenix.HTML.Form.normalize_value(\"checkbox\", value) end)\n\n    ~H\"\"\"\n    <div phx-feedback-for={@name}>\n      <label class=\"flex items-center gap-4 text-sm leading-6 text-white\">\n        <input type=\"hidden\" name={@name} value=\"false\" />\n        <input\n          type=\"checkbox\"\n          id={@id}\n          name={@name}\n          value=\"true\"\n          checked={@checked}\n          class=\"rounded border-white/10 bg-white/5 text-white/5\"\n          {@rest}\n        />\n        <%= @label %>\n      </label>\n      <.error :for={msg <- @errors}><%= msg %></.error>\n    </div>\n    \"\"\"\n  end\n\n  def input(%{type: \"select\"} = assigns) do\n    ~H\"\"\"\n    <div phx-feedback-for={@name}>\n      <.label for={@id}><%= @label %></.label>\n      <select\n        id={@id}\n        name={@name}\n        class=\"mt-2 block w-full rounded-md text-white border-0 bg-white/5 ring-1 ring-inset ring-white/10 focus:ring-2 focus:ring-inset focus:ring-gray-500 sm:text-sm\"\n        multiple={@multiple}\n        {@rest}\n      >\n        <option :if={@prompt} value=\"\"><%= @prompt %></option>\n        <%= Phoenix.HTML.Form.options_for_select(@options, @value) %>\n      </select>\n      <.error :for={msg <- @errors}><%= msg %></.error>\n    </div>\n    \"\"\"\n  end\n\n  def input(%{type: \"textarea\"} = assigns) do\n    ~H\"\"\"\n    <div phx-feedback-for={@name}>\n      <.label for={@id}><%= @label %></.label>\n      <textarea\n        id={@id}\n        name={@name}\n        class={[\n          \"mt-2 block w-full rounded-lg border-0 bg-white/5 py-1.5 text-white shadow-sm ring-1 ring-inset ring-white/10 focus:ring-2 focus:ring-inset focus:ring-gray-500 sm:text-sm sm:leading-6\",\n          \"min-h-[6rem] phx-no-feedback:border-zinc-300 phx-no-feedback:focus:border-zinc-400\",\n          @errors == [] && \"border-zinc-300 focus:border-zinc-400\",\n          @errors != [] && \"border-rose-400 focus:border-rose-400\"\n        ]}\n        {@rest}\n      ><%= Phoenix.HTML.Form.normalize_value(\"textarea\", @value) %></textarea>\n      <.error :for={msg <- @errors}><%= msg %></.error>\n    </div>\n    \"\"\"\n  end\n\n  # All other inputs text, datetime-local, url, password, etc. are handled here...\n  def input(assigns) do\n    ~H\"\"\"\n    <div phx-feedback-for={@name}>\n      <.label for={@id}><%= @label %></.label>\n      <div class=\"mt-2\">\n        <div class={[\n          \"flex rounded-md bg-white/5 ring-1 ring-inset ring-white/10 focus-within:ring-2 focus-within:ring-inset\",\n          @errors == [] && \"focus-within:ring-gray-500\",\n          @errors != [] && \"focus-within:ring-rose-500\"\n        ]}>\n          <input\n            type={@type}\n            name={@name}\n            id={@id}\n            value={Phoenix.HTML.Form.normalize_value(@type, @value)}\n            class=\"flex-1 border-0 bg-transparent py-1.5 pl-1 text-white focus:ring-0 sm:text-sm sm:leading-6\"\n            {@rest}\n          />\n        </div>\n        <.error :for={msg <- @errors}><%= msg %></.error>\n      </div>\n    </div>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Renders a label.\n  \"\"\"\n  attr :for, :string, default: nil\n  slot :inner_block, required: true\n\n  def label(assigns) do\n    ~H\"\"\"\n    <label for={@for} class=\"block text-sm font-semibold leading-6 text-white\">\n      <%= render_slot(@inner_block) %>\n    </label>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Generates a generic error message.\n  \"\"\"\n  slot :inner_block, required: true\n\n  def error(assigns) do\n    ~H\"\"\"\n    <p class=\"mt-3 flex gap-3 text-sm leading-6 text-rose-600 phx-no-feedback:hidden\">\n      <.icon name=\"hero-exclamation-circle-mini\" class=\"mt-0.5 h-5 w-5 flex-none\" />\n      <%= render_slot(@inner_block) %>\n    </p>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Renders a header with title.\n  \"\"\"\n  attr :class, :string, default: nil\n\n  slot :inner_block, required: true\n  slot :subtitle\n  slot :actions\n\n  def header(assigns) do\n    ~H\"\"\"\n    <header class={[@actions != [] && \"flex items-center justify-between gap-6\", @class]}>\n      <div>\n        <h1 class=\"text-lg font-semibold leading-8 text-zinc-800\">\n          <%= render_slot(@inner_block) %>\n        </h1>\n        <p :if={@subtitle != []} class=\"mt-2 text-sm leading-6 text-zinc-600\">\n          <%= render_slot(@subtitle) %>\n        </p>\n      </div>\n      <div class=\"flex-none\"><%= render_slot(@actions) %></div>\n    </header>\n    \"\"\"\n  end\n\n  @doc ~S\"\"\"\n  Renders a table with generic styling.\n\n  ## Examples\n\n      <.table id=\"users\" rows={@users}>\n        <:col :let={user} label=\"id\"><%= user.id %></:col>\n        <:col :let={user} label=\"username\"><%= user.username %></:col>\n      </.table>\n  \"\"\"\n  attr :id, :string, required: true\n  attr :rows, :list, required: true\n  attr :row_id, :any, default: nil, doc: \"the function for generating the row id\"\n  attr :row_click, :any, default: nil, doc: \"the function for handling phx-click on each row\"\n\n  attr :row_item, :any,\n    default: &Function.identity/1,\n    doc: \"the function for mapping each row before calling the :col and :action slots\"\n\n  slot :col, required: true do\n    attr :label, :string\n  end\n\n  slot :action, doc: \"the slot for showing user actions in the last table column\"\n\n  def table(assigns) do\n    assigns =\n      with %{rows: %Phoenix.LiveView.LiveStream{}} <- assigns do\n        assign(assigns, row_id: assigns.row_id || fn {id, _item} -> id end)\n      end\n\n    ~H\"\"\"\n    <div class=\"overflow-y-auto px-4 sm:overflow-visible sm:px-0\">\n      <table class=\"w-[40rem] mt-11 sm:w-full\">\n        <thead class=\"text-sm text-left leading-6 text-zinc-500\">\n          <tr>\n            <th :for={col <- @col} class=\"p-0 pr-6 pb-4 font-normal\"><%= col[:label] %></th>\n            <th class=\"relative p-0 pb-4\"><span class=\"sr-only\"><%= gettext(\"Actions\") %></span></th>\n          </tr>\n        </thead>\n        <tbody\n          id={@id}\n          phx-update={match?(%Phoenix.LiveView.LiveStream{}, @rows) && \"stream\"}\n          class=\"relative divide-y divide-zinc-100 border-t border-zinc-200 text-sm leading-6 text-zinc-700\"\n        >\n          <tr :for={row <- @rows} id={@row_id && @row_id.(row)} class=\"group hover:bg-zinc-50\">\n            <td\n              :for={{col, i} <- Enum.with_index(@col)}\n              phx-click={@row_click && @row_click.(row)}\n              class={[\"relative p-0\", @row_click && \"hover:cursor-pointer\"]}\n            >\n              <div class=\"block py-4 pr-6\">\n                <span class=\"absolute -inset-y-px right-0 -left-4 group-hover:bg-zinc-50 sm:rounded-l-xl\" />\n                <span class={[\"relative\", i == 0 && \"font-semibold text-zinc-900\"]}>\n                  <%= render_slot(col, @row_item.(row)) %>\n                </span>\n              </div>\n            </td>\n            <td :if={@action != []} class=\"relative w-14 p-0\">\n              <div class=\"relative whitespace-nowrap py-4 text-right text-sm font-medium\">\n                <span class=\"absolute -inset-y-px -right-4 left-0 group-hover:bg-zinc-50 sm:rounded-r-xl\" />\n                <span\n                  :for={action <- @action}\n                  class=\"relative ml-4 font-semibold leading-6 text-zinc-900 hover:text-zinc-700\"\n                >\n                  <%= render_slot(action, @row_item.(row)) %>\n                </span>\n              </div>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Renders a data list.\n\n  ## Examples\n\n      <.list>\n        <:item title=\"Title\"><%= @post.title %></:item>\n        <:item title=\"Views\"><%= @post.views %></:item>\n      </.list>\n  \"\"\"\n  slot :item, required: true do\n    attr :title, :string, required: true\n  end\n\n  def list(assigns) do\n    ~H\"\"\"\n    <div class=\"mt-14\">\n      <dl class=\"-my-4 divide-y divide-zinc-100\">\n        <div :for={item <- @item} class=\"flex gap-4 py-4 text-sm leading-6 sm:gap-8\">\n          <dt class=\"w-1/4 flex-none text-zinc-500\"><%= item.title %></dt>\n          <dd class=\"text-zinc-700\"><%= render_slot(item) %></dd>\n        </div>\n      </dl>\n    </div>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Renders a back navigation link.\n\n  ## Examples\n\n      <.back navigate={~p\"/posts\"}>Back to posts</.back>\n  \"\"\"\n  attr :navigate, :any, required: true\n  slot :inner_block, required: true\n\n  def back(assigns) do\n    ~H\"\"\"\n    <div class=\"mt-16\">\n      <.link navigate={@navigate} class=\"text-sm font-semibold leading-6 text-zinc-900 hover:text-zinc-700\">\n        <.icon name=\"hero-arrow-left-solid\" class=\"h-3 w-3\" />\n        <%= render_slot(@inner_block) %>\n      </.link>\n    </div>\n    \"\"\"\n  end\n\n  @doc \"\"\"\n  Renders a [Heroicon](https://heroicons.com).\n\n  Heroicons come in three styles – outline, solid, and mini.\n  By default, the outline style is used, but solid and mini may\n  be applied by using the `-solid` and `-mini` suffix.\n\n  You can customize the size and colors of the icons by setting\n  width, height, and background color classes.\n\n  Icons are extracted from your `assets/vendor/heroicons` directory and bundled\n  within your compiled app.css by the plugin in your `assets/tailwind.config.js`.\n\n  ## Examples\n\n      <.icon name=\"hero-x-mark-solid\" />\n      <.icon name=\"hero-arrow-path\" class=\"ml-1 w-3 h-3 animate-spin\" />\n  \"\"\"\n  attr :name, :string, required: true\n  attr :class, :string, default: nil\n\n  def icon(%{name: \"hero-\" <> _} = assigns) do\n    ~H\"\"\"\n    <span class={[@name, @class]} />\n    \"\"\"\n  end\n\n  ## JS Commands\n\n  def show(js \\\\ %JS{}, selector) do\n    JS.show(js,\n      to: selector,\n      transition:\n        {\"transition-all transform ease-out duration-300\", \"opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95\",\n         \"opacity-100 translate-y-0 sm:scale-100\"}\n    )\n  end\n\n  def hide(js \\\\ %JS{}, selector) do\n    JS.hide(js,\n      to: selector,\n      time: 200,\n      transition:\n        {\"transition-all transform ease-in duration-200\", \"opacity-100 translate-y-0 sm:scale-100\",\n         \"opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95\"}\n    )\n  end\n\n  def show_modal(js \\\\ %JS{}, id) when is_binary(id) do\n    js\n    |> JS.show(to: \"##{id}\")\n    |> JS.show(\n      to: \"##{id}-bg\",\n      transition: {\"transition-all transform ease-out duration-300\", \"opacity-0\", \"opacity-100\"}\n    )\n    |> show(\"##{id}-container\")\n    |> JS.add_class(\"overflow-hidden\", to: \"body\")\n    |> JS.focus_first(to: \"##{id}-content\")\n  end\n\n  def hide_modal(js \\\\ %JS{}, id) do\n    js\n    |> JS.hide(\n      to: \"##{id}-bg\",\n      transition: {\"transition-all transform ease-in duration-200\", \"opacity-100\", \"opacity-0\"}\n    )\n    |> hide(\"##{id}-container\")\n    |> JS.hide(to: \"##{id}\", transition: {\"block\", \"block\", \"hidden\"})\n    |> JS.remove_class(\"overflow-hidden\", to: \"body\")\n    |> JS.pop_focus()\n  end\n\n  @doc \"\"\"\n  Translates an error message using gettext.\n  \"\"\"\n  def translate_error({msg, opts}) do\n    # When using gettext, we typically pass the strings we want\n    # to translate as a static argument:\n    #\n    #     # Translate the number of files with plural rules\n    #     dngettext(\"errors\", \"1 file\", \"%{count} files\", count)\n    #\n    # However the error messages in our forms and APIs are generated\n    # dynamically, so we need to translate them by calling Gettext\n    # with our gettext backend as first argument. Translations are\n    # available in the errors.po file (as we use the \"errors\" domain).\n    if count = opts[:count] do\n      Gettext.dngettext(SpendableWeb.Gettext, \"errors\", msg, msg, count, opts)\n    else\n      Gettext.dgettext(SpendableWeb.Gettext, \"errors\", msg, opts)\n    end\n  end\n\n  @doc \"\"\"\n  Translates the errors for a field from a keyword list of errors.\n  \"\"\"\n  def translate_errors(errors, field) when is_list(errors) do\n    for {^field, {msg, opts}} <- errors, do: translate_error({msg, opts})\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,null,null,0,null,null,0,0,null,null,null,null,null,null,0,0,0,null,0,null,null,null,0,0,null,null,0,null,0,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,2,4,2,2,null,null,null,2,2,null,2,null,2,2,2,2,null,null,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,1,null,null,null,null,null,null,null,1,null,null,1,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,8,8,null,8,8,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,22,22,22,22,22,null,null,null,4,4,null,4,4,null,4,4,null,4,4,null,4,null,4,null,3,null,4,null,null,null,null,null,4,4,4,4,4,4,null,4,4,null,4,4,null,4,null,null,null,null,null,0,0,0,0,0,0,null,null,null,0,0,null,0,0,0,null,null,null,null,null,null,14,14,14,null,null,null,14,14,null,12,12,14,14,14,null,14,null,null,14,null,null,null,null,null,null,null,null,null,null,null,null,18,18,16,null,null,null,null,null,null,null,null,null,null,4,null,4,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,0,null,null,null,null,0,0,null,null,0,0,0,null,null,0,null,0,0,0,null,null,null,0,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,63,63,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,null,null,null,null,0,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,0,null,4,null,null,null,null,null,null,null,0,null,null]},{"name":"lib/spendable_web/live/banks.ex","source":"defmodule SpendableWeb.Live.Banks do\n  use SpendableWeb, :live_view\n\n  alias Spendable.BankMember\n\n  def mount(_params, _session, socket) do\n    {:ok, socket}\n  end\n\n  def handle_params(_unsigned_params, _uri, socket) do\n    {:noreply, socket |> fetch_data()}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <div>\n      <main id=\"banks\">\n        <header class=\"flex items-center justify-between border-b border-white/5 px-4 py-4 sm:px-6 sm:py-6 lg:px-8\">\n          <h1 class=\"text-base font-semibold leading-7 text-white\">Banks</h1>\n        </header>\n\n        <ul role=\"list\" class=\"divide-y divide-white/5\">\n          <li\n            :for={bank_member <- @bank_members}\n            phx-click={JS.push(\"select_bank_member\") |> show_details()}\n            phx-value-id={bank_member.id}\n            class=\"relative flex flex-row items-center justify-between space-x-4 px-4 py-6 sm:px-6 lg:px-8\"\n          >\n            <div class=\"min-w-0\">\n              <div class=\"flex items-center\">\n                <img src={\"data:image/png;base64,#{bank_member.logo}\"} alt=\"bank logo\" class=\"h-8 mr-2\" />\n                <h2 class=\"min-w-0 text-sm font-semibold leading-6 text-white\">\n                  <span class=\"truncate\"><%= bank_member.name %></span>\n                </h2>\n              </div>\n            </div>\n            <div class=\"flex items-center\">\n              <div :if={bank_member.status != \"CONNECTED\"} class=\"min-w-0 flex-auto mr-4\">\n                <div class=\"flex items-center gap-x-3\">\n                  <h2 class=\"w-full text-sm font-semibold leading-6 text-red-500 text-right\">\n                    <span class=\"truncate\">\n                      Reconnect <.icon name=\"hero-exclamation-circle\" />\n                    </span>\n                  </h2>\n                </div>\n              </div>\n              <.icon name=\"hero-chevron-right-mini\" class=\"h-5 w-5 flex-none text-gray-400\" />\n            </div>\n          </li>\n        </ul>\n      </main>\n      <aside\n        id=\"details-form\"\n        class=\"hidden bg-black/10 lg:fixed lg:bottom-0 lg:right-0 lg:top-16 lg:w-96 lg:overflow-y-auto lg:border-l lg:border-white/5 text-white\"\n      >\n        <.simple_form :if={@form} for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n          <header class=\"flex items-center justify-between border-b border-white/5 p-6\">\n            <h2 class=\"text-base font-semibold leading-7\">Edit transaction</h2>\n            <button phx-click={hide_details()} class=\"text-sm font-semibold leading-6 text-blue-400\">\n              Save\n            </button>\n          </header>\n          <div class=\"space-y-6 m-6\">\n            <.input type=\"text\" label=\"Name\" field={@form[:name]} />\n            <.input type=\"text\" label=\"Amount\" field={@form[:amount]} />\n            <.input type=\"date\" label=\"Date\" field={@form[:date]} />\n            <div>\n              <div class=\"flex justify-between mt-2\">\n                <button type=\"button\" phx-click=\"split\" class=\"text-sm font-semibold text-blue-400\">\n                  Split\n                </button>\n                <div class=\"relative\">\n                  <button\n                    type=\"button\"\n                    class=\"text-sm font-semibold text-blue-400\"\n                    id=\"sort-menu-button\"\n                    phx-click={JS.toggle(to: \"#template-options\")}\n                  >\n                    Apply Template\n                  </button>\n                  <div\n                    id=\"template-options\"\n                    class=\"hidden absolute right-0 z-10 mt-2.5 w-40 origin-top-right rounded-md bg-white max-h-96 overflow-auto shadow-lg ring-1 ring-gray-900/5 focus:outline-none divide-y\"\n                    phx-click-away={JS.hide(to: \"#template-options\")}\n                  >\n                    <button\n                      :for={{template_name, template_id} <- @template_form_options}\n                      type=\"button\"\n                      class=\"block px-3 py-2 w-full text-sm leading-6 text-gray-900 flex flex-col hover:bg-gray-200\"\n                      phx-click={JS.push(\"apply_template\") |> JS.toggle(to: \"#template-options\")}\n                      phx-value-template={template_id}\n                    >\n                      <div><%= template_name %></div>\n                    </button>\n                  </div>\n                </div>\n              </div>\n            </div>\n            <.input type=\"textarea\" label=\"Note\" field={@form[:note]} />\n            <.input type=\"checkbox\" label=\"Reviewed\" field={@form[:reviewed]} />\n          </div>\n        </.simple_form>\n      </aside>\n    </div>\n    \"\"\"\n  end\n\n  def handle_event(\"validate\", %{\"form\" => params}, socket) do\n    form = AshPhoenix.Form.validate(socket.assigns.form, params)\n    {:noreply, assign(socket, form: form)}\n  end\n\n  def handle_event(\"submit\", %{\"form\" => params}, socket) do\n    case AshPhoenix.Form.submit(socket.assigns.form, params: params) do\n      {:ok, _bank_member} ->\n        {:noreply, socket |> assign(:form, nil)}\n\n      {:error, form} ->\n        {:noreply, assign(socket, form: form)}\n    end\n  end\n\n  def handle_event(\"search\", params, socket) do\n    {:noreply,\n     socket\n     |> assign(:search, params[\"search\"])\n     |> fetch_data()}\n  end\n\n  def handle_event(\"select_bank_member\", params, socket) do\n    bank_member =\n      Enum.find(socket.assigns.bank_members, &(to_string(&1.id) == params[\"id\"]))\n\n    form =\n      bank_member\n      |> AshPhoenix.Form.for_update(:update,\n        api: Spendable.Api,\n        actor: socket.assigns.current_user,\n        forms: [auto?: true]\n      )\n      |> to_form()\n\n    {:noreply,\n     socket\n     |> assign(:form, form)}\n  end\n\n  def show_details(js \\\\ %JS{}) do\n    js\n    |> JS.show(to: \"#details-form\", transition: \"fade-in\")\n    |> JS.add_class(\n      \"lg:pr-96\",\n      to: \"#banks\"\n    )\n  end\n\n  def hide_details(js \\\\ %JS{}) do\n    js\n    |> JS.hide(to: \"#details-form\", transition: \"fade-out\")\n    |> JS.remove_class(\n      \"lg:pr-96\",\n      to: \"#banks\",\n      transition: \"fade-out\"\n    )\n  end\n\n  defp fetch_data(socket) do\n    bank_members =\n      BankMember.list(socket.assigns.current_user.id,\n        search: socket.assigns[:search]\n      )\n\n    socket\n    |> assign(:bank_members, bank_members)\n    |> assign(:form, nil)\n  end\nend","coverage":[null,null,null,null,null,0,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,0,null,0,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,0,0,0,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,0,0,null,null,null,null,0,0,null,null,0,null,null,null,null,0,null,null,null,null,null,null,0,0,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,0,null,null,null,null,0,null,null]},{"name":"lib/spendable_web/live/user_auth.ex","source":"defmodule SpendableWeb.Live.UserAuth do\n  import Phoenix.Component\n  import Phoenix.LiveView\n\n  alias Spendable.User\n\n  def on_mount(:ensure_authenticated, _params, %{\"current_user_id\" => id}, socket) do\n    socket =\n      socket\n      |> assign_new(:current_user, fn ->\n        case Spendable.Api.get(User, id) do\n          {:ok, user} -> user\n          {:error, _} -> nil\n        end\n      end)\n\n    if socket.assigns.current_user do\n      {:cont, socket}\n    else\n      {:halt, redirect(socket, to: \"/\")}\n    end\n  end\n\n  def on_mount(:ensure_authenticated, _params, _session, socket) do\n    {:halt, redirect(socket, to: \"/\")}\n  end\nend","coverage":[null,null,null,null,null,null,null,4,null,null,4,4,0,null,null,null,4,null,null,null,null,null,null,0,null,null,null]},{"name":"lib/spendable_web/live/transactions.ex","source":"defmodule SpendableWeb.Live.Transactions do\n  use SpendableWeb, :live_view\n\n  alias Spendable.Transaction\n  alias Spendable.Utils\n\n  def mount(_params, _session, socket) do\n    {:ok, assign(socket, page: 1, per_page: 25)}\n  end\n\n  def handle_params(_unsigned_params, _uri, socket) do\n    {:noreply, socket |> fetch_data()}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <div>\n      <main id=\"transactions\" phx-click={hide_details()}>\n        <header class=\"flex items-center justify-between border-b border-white/5 px-4 py-4 sm:px-6 sm:py-6 lg:px-8\">\n          <h1 class=\"text-base font-semibold leading-7 text-white\">Transactions</h1>\n        </header>\n\n        <ul\n          id=\"transactions-list\"\n          phx-update=\"stream\"\n          phx-viewport-top={@page > 1 && \"prev-page\"}\n          phx-viewport-bottom={!@end_of_timeline? && \"next-page\"}\n          phx-page-loading\n          class={[\n            \"divide-y divide-white/5\",\n            if(@end_of_timeline?, do: \"pb-10\", else: \"pb-[calc(200vh)]\"),\n            if(@page == 1, do: \"\", else: \"pt-[calc(200vh)]\")\n          ]}\n        >\n          <li\n            :for={{id, transaction} <- @streams.transactions}\n            id={id}\n            phx-click={JS.push(\"select_transaction\") |> show_details()}\n            phx-value-id={transaction.id}\n            class=\"relative flex flex-row items-center justify-between space-x-4 px-4 py-6 sm:px-6 lg:px-8\"\n          >\n            <div class=\"min-w-0 flex-auto\">\n              <div class=\"flex items-center gap-x-3\">\n                <h2 class=\"min-w-0 text-sm font-semibold leading-6 text-white\">\n                  <span class=\"truncate\"><%= transaction.name %></span>\n                </h2>\n              </div>\n              <div class=\"mt-2 flex items-center gap-x-2.5 text-xs leading-5 text-gray-400\">\n                <p class=\"truncate\"><%= Timex.format!(transaction.date, \"{Mshort} {D}, {YYYY}\") %></p>\n              </div>\n            </div>\n            <div class=\"flex items-center\">\n              <div class=\"min-w-0 flex-auto mr-4\">\n                <div class=\"flex items-center gap-x-3\">\n                  <h2 class=\"w-full text-sm font-semibold leading-6 text-white text-right\">\n                    <span class=\"truncate\"><%= Utils.format_currency(transaction.amount) %></span>\n                  </h2>\n                </div>\n              </div>\n              <div\n                :if={transaction.reviewed}\n                class=\"rounded-full flex-none py-1 px-2 text-xs font-medium ring-1 ring-inset text-green-400 bg-green-400/10 ring-green-400/20\"\n              >\n                Reviewed\n              </div>\n              <.icon name=\"hero-chevron-right-mini\" class=\"h-5 w-5 flex-none text-gray-400\" />\n            </div>\n          </li>\n        </ul>\n      </main>\n      <aside\n        id=\"transaction-details\"\n        class=\"hidden bg-black/10 lg:fixed lg:bottom-0 lg:right-0 lg:top-16 lg:w-96 lg:overflow-y-auto lg:border-l lg:border-white/5 text-white\"\n      >\n        <.simple_form :if={@form} for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n          <header class=\"flex items-center justify-between border-b border-white/5 p-6\">\n            <h2 class=\"text-base font-semibold leading-7\">Edit transaction</h2>\n            <button phx-click={hide_details()} class=\"text-sm font-semibold leading-6 text-blue-400\">\n              Save\n            </button>\n          </header>\n          <div class=\"space-y-6 m-6\">\n            <.input type=\"text\" label=\"Name\" field={@form[:name]} />\n            <.input type=\"text\" label=\"Amount\" field={@form[:amount]} />\n            <.input type=\"date\" label=\"Date\" field={@form[:date]} />\n            <div>\n              <%= if length(@form.source.forms[:budget_allocations]) <= 1 do %>\n                <.inputs_for :let={allocation_form} field={@form[:budget_allocations]}>\n                  <.input\n                    type=\"select\"\n                    label={if Decimal.negative?(@form[:amount].value), do: \"Spend from\", else: \"Add to\"}\n                    field={allocation_form[:budget_id]}\n                    options={@budget_form_options}\n                  />\n                </.inputs_for>\n              <% else %>\n                <div class=\"grid grid-cols-10\">\n                  <div class=\"col-span-6\">\n                    <%= if Decimal.negative?(@form[:amount].value), do: \"Spend from\", else: \"Add to\" %>\n                  </div>\n                  <div class=\"col-span-3\">\n                    Amount\n                  </div>\n                </div>\n                <.inputs_for :let={allocation_form} field={@form[:budget_allocations]}>\n                  <div class=\"grid grid-cols-10 items-center\">\n                    <div class=\"col-span-6 pr-2\">\n                      <.input type=\"select\" field={allocation_form[:budget_id]} options={@budget_form_options} />\n                    </div>\n                    <div class=\"col-span-3\">\n                      <.input type=\"text\" field={allocation_form[:amount]} />\n                    </div>\n                    <button\n                      type=\"button\"\n                      class=\"cursor-pointer text-right mt-1\"\n                      phx-click=\"remove_allocation\"\n                      phx-value-path={allocation_form.name}\n                    >\n                      <.icon name=\"hero-x-circle\" />\n                    </button>\n                  </div>\n                </.inputs_for>\n              <% end %>\n              <div class=\"flex justify-between mt-2\">\n                <button type=\"button\" phx-click=\"split\" class=\"text-sm font-semibold text-blue-400\">\n                  Split\n                </button>\n                <div class=\"relative\">\n                  <button\n                    type=\"button\"\n                    class=\"text-sm font-semibold text-blue-400\"\n                    id=\"sort-menu-button\"\n                    phx-click={JS.toggle(to: \"#template-options\")}\n                  >\n                    Apply Template\n                  </button>\n                  <div\n                    id=\"template-options\"\n                    class=\"hidden absolute right-0 z-10 mt-2.5 w-40 origin-top-right rounded-md bg-white max-h-96 overflow-auto shadow-lg ring-1 ring-gray-900/5 focus:outline-none divide-y\"\n                    phx-click-away={JS.hide(to: \"#template-options\")}\n                  >\n                    <button\n                      :for={{template_name, template_id} <- @template_form_options}\n                      type=\"button\"\n                      class=\"block px-3 py-2 w-full text-sm leading-6 text-gray-900 flex flex-col hover:bg-gray-200\"\n                      phx-click={JS.push(\"apply_template\") |> JS.toggle(to: \"#template-options\")}\n                      phx-value-template={template_id}\n                    >\n                      <div><%= template_name %></div>\n                    </button>\n                  </div>\n                </div>\n              </div>\n            </div>\n            <.input type=\"textarea\" label=\"Note\" field={@form[:note]} />\n            <.input type=\"checkbox\" label=\"Reviewed\" field={@form[:reviewed]} />\n          </div>\n        </.simple_form>\n      </aside>\n    </div>\n    \"\"\"\n  end\n\n  def handle_event(\"validate\", %{\"form\" => params}, socket) do\n    form = AshPhoenix.Form.validate(socket.assigns.form, params)\n    {:noreply, assign(socket, form: form)}\n  end\n\n  def handle_event(\"submit\", %{\"form\" => params}, socket) do\n    params =\n      if Enum.count(params[\"budget_allocations\"]) == 1 do\n        %{\n          params\n          | \"budget_allocations\" => %{\n              \"0\" => Map.put(params[\"budget_allocations\"][\"0\"], \"amount\", params[\"amount\"])\n            }\n        }\n      else\n        params\n      end\n\n    case AshPhoenix.Form.submit(socket.assigns.form, params: params) do\n      {:ok, updated_transaction} ->\n        transactions =\n          Enum.map(socket.assigns.transactions, fn transaction ->\n            if updated_transaction.id == transaction.id do\n              updated_transaction\n            else\n              transaction\n            end\n          end)\n\n        {:noreply, socket |> assign(transactions: transactions) |> assign(:form, nil)}\n\n      {:error, form} ->\n        {:noreply, assign(socket, form: form)}\n    end\n  end\n\n  def handle_event(\"apply_template\", params, socket) do\n    form =\n      Enum.reduce(socket.assigns.form.source.forms[:budget_allocations], socket.assigns.form, fn allocation_form, acc ->\n        AshPhoenix.Form.remove_form(acc, allocation_form.name)\n      end)\n\n    form =\n      Transaction.get_template(params[\"template\"])\n      |> Map.get(:budget_allocation_template_lines, [])\n      |> Enum.reduce(form, fn line, acc ->\n        AshPhoenix.Form.add_form(acc, [:budget_allocations], params: %{amount: line.amount, budget_id: line.budget_id})\n      end)\n\n    {:noreply, assign(socket, form: form)}\n  end\n\n  def handle_event(\"split\", _params, socket) do\n    form = AshPhoenix.Form.add_form(socket.assigns.form, [:budget_allocations])\n    {:noreply, assign(socket, form: form)}\n  end\n\n  def handle_event(\"remove_allocation\", %{\"path\" => path}, socket) do\n    form = AshPhoenix.Form.remove_form(socket.assigns.form, path)\n    {:noreply, assign(socket, form: form)}\n  end\n\n  def handle_event(\"search\", params, socket) do\n    {:noreply,\n     socket\n     |> assign(search: params[\"search\"])\n     |> paginate_posts(1, true)}\n  end\n\n  def handle_event(\"select_transaction\", params, socket) do\n    transaction =\n      Enum.find(socket.assigns.transactions, &(to_string(&1.id) == params[\"id\"]))\n      |> Spendable.Api.load!(:budget_allocations)\n\n    form =\n      transaction\n      |> AshPhoenix.Form.for_update(:update,\n        api: Spendable.Api,\n        actor: socket.assigns.current_user,\n        forms: [auto?: true]\n      )\n      |> to_form()\n\n    {:noreply,\n     socket\n     |> assign(:form, form)}\n  end\n\n  def handle_event(\"next-page\", _params, socket) do\n    {:noreply, paginate_posts(socket, socket.assigns.page + 1)}\n  end\n\n  def handle_event(\"prev-page\", %{\"_overran\" => true}, socket) do\n    {:noreply, paginate_posts(socket, 1)}\n  end\n\n  def handle_event(\"prev-page\", _params, socket) do\n    if socket.assigns.page > 1 do\n      {:noreply, paginate_posts(socket, socket.assigns.page - 1)}\n    else\n      {:noreply, socket}\n    end\n  end\n\n  def show_details(js \\\\ %JS{}) do\n    js\n    |> JS.show(to: \"#transaction-details\", transition: \"fade-in\")\n    |> JS.add_class(\n      \"lg:pr-96\",\n      to: \"#transactions\"\n    )\n  end\n\n  def hide_details(js \\\\ %JS{}) do\n    js\n    |> JS.hide(to: \"#transaction-details\", transition: \"fade-out\")\n    |> JS.remove_class(\n      \"lg:pr-96\",\n      to: \"#transactions\",\n      transition: \"fade-out\"\n    )\n  end\n\n  defp fetch_data(socket) do\n    budget_form_options = Transaction.budget_form_options(socket.assigns.current_user.id)\n    template_form_options = Transaction.template_form_options(socket.assigns.current_user.id)\n\n    socket\n    |> assign(\n      budget_form_options: budget_form_options,\n      template_form_options: template_form_options,\n      form: nil\n    )\n    |> paginate_posts(1)\n  end\n\n  defp paginate_posts(socket, new_page, reset \\\\ false) when new_page >= 1 do\n    %{per_page: per_page, page: page} = socket.assigns\n\n    transactions =\n      Transaction.list_transactions(socket.assigns.current_user.id,\n        search: socket.assigns[:search],\n        page: new_page,\n        per_page: per_page\n      )\n\n    {transactions, at, limit} =\n      if new_page >= page do\n        {transactions, -1, per_page * 3 * -1}\n      else\n        {Enum.reverse(transactions), 0, per_page * 3}\n      end\n\n    case transactions do\n      [] ->\n        assign(socket, end_of_timeline?: at == -1)\n\n      [_ | _] = transactions ->\n        socket\n        |> assign(end_of_timeline?: false)\n        |> assign(:page, new_page)\n        |> stream(:transactions, transactions, at: at, limit: limit, reset: reset)\n    end\n  end\nend","coverage":[null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,0,null,0,null,null,null,null,0,null,null,0,0,null,null,null,0,0,null,null,null,0,null,null,0,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,0,0,0,null,0,0,null,null,0,null,0,null,null,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,0,0,null,null,null,0,0,null,null,null,0,null,null,null,null,0,null,null,0,null,0,0,0,0,null,0,null,null,null,null,null,0,null,null,null,null,0,0,0,0,null,null,0,null,null,null,0,null,null,null,null,null,0,0,null,null,null,0,0,null,null,null,0,null,null,null,null,null,null,0,0,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,0,null,null,null,0,null,0,0,0,null,null,null,null,0,null,0,null,0,null,null,0,null,0,null,null,null,null,null,0,null,null,null]},{"name":"lib/spendable/resources/user/calculations/spent_by_month.ex","source":"defmodule Spendable.User.Calculations.SpentByMonth do\n  use Ash.Calculation, type: :decimal\n\n  import Ecto.Query\n\n  alias Spendable.Repo\n  alias Spendable.Transaction\n\n  @impl Ash.Calculation\n  def calculate([user], _opts, _resolution) do\n    query =\n      from t in Transaction,\n        select: %{\n          month: fragment(\"TO_CHAR(?, 'YYYY-MM-01')::date\", t.date),\n          spent: sum(t.amount) |> coalesce(^Decimal.new(0))\n        },\n        where: t.user_id == ^user.id,\n        where: t.amount < 0,\n        group_by: fragment(\"TO_CHAR(?, 'YYYY-MM-01')\", t.date),\n        order_by: [desc: fragment(\"TO_CHAR(?, 'YYYY-MM-01')\", t.date)]\n\n    current_month = Date.utc_today() |> Timex.beginning_of_month()\n\n    months =\n      case Repo.all(query) do\n        [%{month: ^current_month} | _rest] = months ->\n          months\n\n        months ->\n          [%{month: current_month, spent: Decimal.new(0)} | months]\n      end\n\n    {:ok, [months]}\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,8,null,null,null,null,null,8,null,null,null,null,8,null,8,null,null,0,null,8,null,null,null,null,null,null]},{"name":"lib/spendable/resources/budget/changes/set_adjustment.ex","source":"defmodule Spendable.Budget.Changes.SetAdjustment do\n  use Ash.Resource.Change\n\n  def change(changeset, _opts, _context) do\n    current_balance = Ash.Changeset.get_data(changeset, :balance)\n    current_adjustment = Ash.Changeset.get_data(changeset, :adjustment)\n    new_balance = Ash.Changeset.get_argument(changeset, :balance) || current_balance\n    adjustment = current_adjustment |> Decimal.add(new_balance) |> Decimal.sub(current_balance)\n\n    changeset\n    |> Ash.Changeset.change_attribute(:adjustment, adjustment)\n    |> Ash.Changeset.after_action(fn _changeset, budget ->\n      {:ok, Map.put(budget, :balance, new_balance)}\n    end)\n  end\nend","coverage":[null,null,null,null,3,3,3,3,null,null,null,3,null,null,null,null]},{"name":"lib/spendable/tracer.ex","source":"defmodule Spendable.Tracer do\n  use Spandex.Tracer, otp_app: :spendable\nend","coverage":[null,null,null]},{"name":"lib/spendable/resources/budget_allocation.ex","source":"defmodule Spendable.BudgetAllocation do\n  use Ash.Resource,\n    authorizers: [Ash.Policy.Authorizer],\n    data_layer: AshPostgres.DataLayer\n\n  postgres do\n    repo(Spendable.Repo)\n    table \"budget_allocations\"\n\n    custom_indexes do\n      index([\"budget_id\"])\n      index([\"transaction_id\"])\n      index([\"user_id\"])\n    end\n  end\n\n  attributes do\n    uuid_primary_key :id\n\n    attribute :amount, :decimal, allow_nil?: false\n\n    timestamps()\n  end\n\n  relationships do\n    belongs_to :transaction, Spendable.Transaction, allow_nil?: false\n    belongs_to :budget, Spendable.Budget, allow_nil?: false\n    belongs_to :user, Spendable.User, allow_nil?: false\n  end\n\n  actions do\n    defaults [:read, :destroy]\n\n    create :create do\n      primary? true\n\n      change relate_actor(:user)\n\n      argument :budget_id, :string\n      change manage_relationship(:budget_id, :budget, type: :append_and_remove)\n    end\n\n    update :update do\n      primary? true\n\n      argument :budget_id, :string\n      change manage_relationship(:budget_id, :budget, type: :append_and_remove)\n    end\n  end\n\n  policies do\n    policy always() do\n      authorize_if action(:create)\n      authorize_if expr(user_id == ^actor(:id))\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable/resources/budget_allocation_template.ex","source":"defmodule Spendable.BudgetAllocationTemplate do\n  use Ash.Resource,\n    authorizers: [Ash.Policy.Authorizer],\n    data_layer: AshPostgres.DataLayer,\n    extensions: [AshArchival.Resource]\n\n  alias Spendable.Budget\n  alias Spendable.BudgetAllocationTemplate.Storage\n\n  require Ash.Query\n\n  postgres do\n    repo(Spendable.Repo)\n    table \"budget_allocation_templates\"\n\n    custom_indexes do\n      index([\"user_id\"])\n    end\n  end\n\n  attributes do\n    uuid_primary_key :id\n\n    attribute :name, :string, allow_nil?: false\n\n    timestamps()\n  end\n\n  relationships do\n    belongs_to :user, Spendable.User, allow_nil?: false\n\n    has_many :budget_allocation_template_lines, Spendable.BudgetAllocationTemplateLine\n  end\n\n  actions do\n    defaults [:read, :destroy]\n\n    read :list do\n      argument :search, :string\n\n      prepare fn query, _context ->\n        search = query.arguments[:search]\n\n        if is_bitstring(search) and byte_size(search) > 0 do\n          Ash.Query.filter(query, contains(name, ^search))\n        else\n          query\n        end\n      end\n\n      prepare build(sort: [:name])\n    end\n\n    create :create do\n      primary? true\n\n      change relate_actor(:user)\n\n      argument :budget_allocation_template_lines, {:array, :map}\n      change manage_relationship(:budget_allocation_template_lines, type: :create)\n    end\n\n    update :update do\n      primary? true\n\n      argument :budget_allocation_template_lines, {:array, :map}\n\n      change manage_relationship(:budget_allocation_template_lines,\n               on_lookup: :relate,\n               on_no_match: :create,\n               on_match: :update,\n               on_missing: :destroy\n             )\n    end\n  end\n\n  policies do\n    policy always() do\n      authorize_if action(:create)\n      authorize_if expr(user_id == ^actor(:id))\n    end\n  end\n\n  def budget_form_options(user_id) do\n    Budget.form_options(user_id)\n  end\n\n  def form_options(user_id) do\n    Storage.form_options(user_id)\n  end\n\n  def get_template(id) do\n    Storage.get_template(id)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,6,0,null,6,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,6,null,null,null,0,null,null,null,0,null,null]},{"name":"lib/spendable/resources/bank_member/storage.ex","source":"defmodule Spendable.BankMember.Storage do\n  alias Spendable.Api\n  alias Spendable.BankMember\n\n  require Ash.Query\n\n  def list(user_id, opts \\\\ []) do\n    BankMember\n    |> Ash.Query.filter(user_id == ^user_id)\n    |> maybe_search(opts[:search])\n    |> Ash.Query.sort(:name)\n    |> Api.read!()\n  end\n\n  defp maybe_search(query, search) when byte_size(search) > 0 do\n    Ash.Query.filter(query, contains(name, ^search))\n  end\n\n  defp maybe_search(query, _search), do: query\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null]},{"name":"lib/spendable/resources/user.ex","source":"defmodule Spendable.User do\n  use Ash.Resource,\n    authorizers: [Ash.Policy.Authorizer],\n    data_layer: AshPostgres.DataLayer\n\n  alias Spendable.User.SpentByMonth\n\n  postgres do\n    repo(Spendable.Repo)\n    table \"users\"\n  end\n\n  identities do\n    identity :external_id, [:external_id]\n  end\n\n  attributes do\n    uuid_primary_key :id\n\n    attribute :bank_limit, :integer, default: 0, allow_nil?: false\n    attribute :external_id, :string, allow_nil?: false\n    attribute :image, :string\n    attribute :provider, :string, allow_nil?: false\n\n    timestamps()\n  end\n\n  calculations do\n    calculate :plaid_link_token, :string, Spendable.User.Calculations.PlaidLinkToken, allow_nil?: false\n\n    calculate :spendable, :decimal, Spendable.User.Calculations.Spendable, allow_nil?: false\n\n    calculate :spent_by_month, {:array, SpentByMonth}, Spendable.User.Calculations.SpentByMonth, allow_nil?: false\n  end\n\n  actions do\n    defaults [:read, :create]\n  end\n\n  policies do\n    policy always() do\n      authorize_if expr(id == ^actor(:id))\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable_web/live/templates.ex","source":"defmodule SpendableWeb.Live.Templates do\n  use SpendableWeb, :live_view\n\n  alias Spendable.BudgetAllocationTemplate\n\n  def mount(_params, _session, socket) do\n    {:ok, socket}\n  end\n\n  def handle_params(_unsigned_params, _uri, socket) do\n    {:noreply, socket |> fetch_data()}\n  end\n\n  def render(assigns) do\n    ~H\"\"\"\n    <div>\n      <main id=\"templates\" phx-click={JS.push(\"close\") |> hide_details()}>\n        <header class=\"flex items-center justify-between border-b border-white/5 px-8 py-6\">\n          <h1 class=\"text-base font-semibold leading-7 text-white\">Transaction templates</h1>\n          <div class=\"flex gap-x-6\">\n            <button\n              :if={is_nil(@form)}\n              id=\"new-template\"\n              type=\"button\"\n              phx-click={JS.push(\"new\") |> show_details()}\n              class=\"text-sm font-semibold leading-6 text-blue-400\"\n            >\n              New\n            </button>\n            <button\n              :if={not Enum.empty?(@selected_templates)}\n              id=\"archive\"\n              type=\"button\"\n              phx-click=\"archive\"\n              class=\"text-sm font-semibold leading-6 text-blue-400\"\n            >\n              Archive (<%= length(@selected_templates) %>)\n            </button>\n            <button\n              :if={not is_nil(@form)}\n              type=\"button\"\n              phx-click={JS.push(\"close\") |> hide_details()}\n              class=\"text-sm font-semibold leading-6 text-blue-400\"\n            >\n              Close\n            </button>\n          </div>\n        </header>\n\n        <ul role=\"list\" class=\"divide-y divide-white/5\">\n          <li\n            :for={template <- @templates}\n            phx-click={JS.push(\"select_template\") |> show_details()}\n            phx-value-id={template.id}\n            class=\"relative flex flex-row items-center justify-between space-x-4 py-6 pr-8\"\n          >\n            <div class=\"min-w-0 flex-auto ml-1\">\n              <div class=\"flex items-center\">\n                <div :if={to_string(template.id) not in @selected_templates} class=\"pl-1 pr-2 opacity-0 hover:opacity-100\">\n                  <input\n                    type=\"checkbox\"\n                    value=\"true\"\n                    checked={false}\n                    phx-click=\"check_template\"\n                    phx-value-id={template.id}\n                    class=\"rounded border-white/10 bg-white/5 text-white/5\"\n                  />\n                </div>\n                <div :if={to_string(template.id) in @selected_templates} class=\"pl-1 pr-2\">\n                  <input\n                    type=\"checkbox\"\n                    value=\"true\"\n                    checked={true}\n                    phx-click=\"uncheck_template\"\n                    phx-value-id={template.id}\n                    class=\"rounded border-white/10 bg-white/5 text-white/5\"\n                  />\n                </div>\n                <h2 class=\"min-w-0 text-sm font-semibold leading-6 text-white\">\n                  <span class=\"truncate\"><%= template.name %></span>\n                </h2>\n              </div>\n            </div>\n            <div class=\"flex items-center\">\n              <.icon name=\"hero-chevron-right-mini\" class=\"h-5 w-5 flex-none text-gray-400\" />\n            </div>\n          </li>\n        </ul>\n      </main>\n      <aside\n        id=\"template-details\"\n        class=\"hidden bg-black/10 lg:fixed lg:bottom-0 lg:right-0 lg:top-16 lg:w-96 lg:overflow-y-auto lg:border-l lg:border-white/5 text-white\"\n      >\n        <.simple_form :if={@form} for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n          <header class=\"flex items-center justify-between border-b border-white/5 p-6\">\n            <h2 class=\"text-base font-semibold leading-7\">Edit template</h2>\n            <button phx-click={hide_details()} class=\"text-sm font-semibold leading-6 text-blue-400\">\n              Save\n            </button>\n          </header>\n          <div class=\"space-y-6 m-6\">\n            <.input type=\"text\" label=\"Name\" field={@form[:name]} />\n            <div>\n              <div class=\"grid grid-cols-10\">\n                <div class=\"col-span-6\">\n                  Budget\n                </div>\n                <div class=\"col-span-3\">\n                  Amount\n                </div>\n              </div>\n              <.inputs_for :let={allocation_form} field={@form[:budget_allocation_template_lines]}>\n                <div class=\"grid grid-cols-10 items-center\">\n                  <div class=\"col-span-6 pr-2\">\n                    <.input type=\"select\" field={allocation_form[:budget_id]} options={@budget_form_options} />\n                  </div>\n                  <div class=\"col-span-3\">\n                    <.input type=\"text\" field={allocation_form[:amount]} />\n                  </div>\n                  <button\n                    type=\"button\"\n                    class=\"cursor-pointer text-right mt-1\"\n                    phx-click=\"remove_allocation\"\n                    phx-value-path={allocation_form.name}\n                  >\n                    <.icon name=\"hero-x-circle\" />\n                  </button>\n                </div>\n              </.inputs_for>\n              <div class=\"flex justify-between mt-2\">\n                <button type=\"button\" phx-click=\"split\" class=\"text-sm font-semibold text-blue-400\">\n                  Split\n                </button>\n              </div>\n            </div>\n          </div>\n        </.simple_form>\n      </aside>\n    </div>\n    \"\"\"\n  end\n\n  def handle_event(\"validate\", %{\"form\" => params}, socket) do\n    form = AshPhoenix.Form.validate(socket.assigns.form, params)\n    {:noreply, assign(socket, form: form)}\n  end\n\n  def handle_event(\"submit\", %{\"form\" => params}, socket) do\n    case AshPhoenix.Form.submit(socket.assigns.form, params: params) do\n      {:ok, _template} ->\n        {:noreply, socket |> assign(:form, nil) |> fetch_data()}\n\n      {:error, form} ->\n        {:noreply, assign(socket, form: form)}\n    end\n  end\n\n  def handle_event(\"split\", _params, socket) do\n    form = AshPhoenix.Form.add_form(socket.assigns.form, [:budget_allocation_template_lines])\n    {:noreply, assign(socket, form: form)}\n  end\n\n  def handle_event(\"archive\", _params, socket) do\n    socket.assigns.templates\n    |> Enum.filter(&(to_string(&1.id) in socket.assigns.selected_templates))\n    |> Enum.each(&Spendable.Api.destroy!/1)\n\n    {:noreply, fetch_data(socket)}\n  end\n\n  def handle_event(\"check_template\", %{\"id\" => id}, socket) do\n    {:noreply, assign(socket, selected_templates: Enum.uniq([id | socket.assigns.selected_templates]))}\n  end\n\n  def handle_event(\"uncheck_template\", %{\"id\" => id}, socket) do\n    {:noreply, assign(socket, selected_templates: Enum.filter(socket.assigns.selected_templates, &(&1 != id)))}\n  end\n\n  def handle_event(\"remove_allocation\", %{\"path\" => path}, socket) do\n    form = AshPhoenix.Form.remove_form(socket.assigns.form, path)\n    {:noreply, assign(socket, form: form)}\n  end\n\n  def handle_event(\"search\", params, socket) do\n    {:noreply,\n     socket\n     |> assign(:search, params[\"search\"])\n     |> fetch_data()}\n  end\n\n  def handle_event(\"close\", _params, socket) do\n    {:noreply, assign(socket, :form, nil)}\n  end\n\n  def handle_event(\"new\", _params, socket) do\n    form =\n      BudgetAllocationTemplate\n      |> AshPhoenix.Form.for_create(:create,\n        api: Spendable.Api,\n        actor: socket.assigns.current_user,\n        forms: [auto?: true]\n      )\n      |> to_form()\n      |> AshPhoenix.Form.add_form([:budget_allocation_template_lines])\n\n    {:noreply, assign(socket, :form, form)}\n  end\n\n  def handle_event(\"select_template\", params, socket) do\n    template =\n      Enum.find(socket.assigns.templates, &(to_string(&1.id) == params[\"id\"]))\n      |> Spendable.Api.load!(:budget_allocation_template_lines)\n\n    form =\n      template\n      |> AshPhoenix.Form.for_update(:update,\n        api: Spendable.Api,\n        actor: socket.assigns.current_user,\n        forms: [auto?: true]\n      )\n      |> to_form()\n\n    {:noreply,\n     socket\n     |> assign(:form, form)}\n  end\n\n  def show_details(js \\\\ %JS{}) do\n    js\n    |> JS.show(to: \"#template-details\", transition: \"fade-in\")\n    |> JS.add_class(\n      \"lg:pr-96\",\n      to: \"#templates\"\n    )\n  end\n\n  def hide_details(js \\\\ %JS{}) do\n    js\n    |> JS.hide(to: \"#template-details\", transition: \"fade-out\")\n    |> JS.remove_class(\n      \"lg:pr-96\",\n      to: \"#templates\",\n      transition: \"fade-out\"\n    )\n  end\n\n  defp fetch_data(socket) do\n    templates =\n      BudgetAllocationTemplate\n      |> Ash.Query.for_read(:list, search: socket.assigns[:search])\n      |> Spendable.Api.read!(actor: socket.assigns.current_user)\n\n    budget_form_options = BudgetAllocationTemplate.budget_form_options(socket.assigns.current_user.id)\n\n    assign(socket,\n      templates: templates,\n      budget_form_options: budget_form_options,\n      form: nil,\n      selected_templates: []\n    )\n  end\nend","coverage":[null,null,null,null,null,2,null,null,null,2,null,null,null,null,13,null,2,null,null,null,5,9,null,null,null,null,null,null,null,null,6,null,null,null,null,null,2,null,3,9,null,null,null,null,null,null,null,null,null,null,null,9,null,12,null,null,null,null,12,10,null,null,null,null,10,null,null,null,12,2,null,null,null,null,2,null,null,null,null,12,null,null,null,null,null,null,null,null,null,null,null,null,null,9,null,null,3,null,null,null,null,4,null,null,null,null,null,null,null,null,null,4,null,null,4,null,null,null,null,null,null,null,null,4,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,3,3,null,null,0,null,null,null,null,0,0,null,null,null,1,1,2,1,null,null,null,null,2,2,null,null,1,1,null,null,0,0,null,null,null,0,null,null,null,null,null,null,0,null,null,null,2,2,null,null,null,2,null,null,null,null,null,null,null,null,1,1,1,null,null,1,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,17,null,null,null,null,null,null,null,null,8,null,null,null,null,null,null,null,6,null,6,6,null,6,null,6,null,null,null,null,null,null,null]},{"name":"lib/spendable/resources/bank_account.ex","source":"defmodule Spendable.BankAccount do\n  use Ash.Resource,\n    authorizers: [Ash.Policy.Authorizer],\n    data_layer: AshPostgres.DataLayer,\n    notifiers: [Spendable.Notifiers.SyncMember]\n\n  postgres do\n    repo(Spendable.Repo)\n    table \"bank_accounts\"\n\n    custom_indexes do\n      index([\"bank_member_id\"])\n    end\n  end\n\n  identities do\n    identity :external_id, [:user_id, :external_id]\n  end\n\n  attributes do\n    uuid_primary_key :id\n\n    attribute :balance, :decimal, allow_nil?: false\n    attribute :external_id, :string, allow_nil?: false\n    attribute :name, :string, allow_nil?: false\n    attribute :number, :string\n    attribute :sub_type, :string, allow_nil?: false\n    attribute :sync, :boolean, allow_nil?: false, default: false\n    attribute :type, :string, allow_nil?: false\n\n    timestamps()\n  end\n\n  relationships do\n    belongs_to :user, Spendable.User, allow_nil?: false\n    belongs_to :bank_member, Spendable.BankMember, allow_nil?: false\n  end\n\n  actions do\n    defaults [:read, :create, :update]\n  end\n\n  policies do\n    policy always() do\n      authorize_if expr(user_id == ^actor(:id))\n    end\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable/utils.ex","source":"defmodule Spendable.Utils do\n  alias Spendable.Api\n  alias Spendable.Budget\n  alias Spendable.Repo\n\n  def get_spendable_id(user) do\n    budget =\n      Repo.get_by(Budget, user_id: user.id, name: \"Spendable\")\n      |> case do\n        nil ->\n          Budget\n          |> Ash.Changeset.for_create(\n            :create,\n            %{\n              name: \"Spendable\",\n              track_spending_only: true\n            },\n            actor: user\n          )\n          |> Api.create!()\n\n        budget ->\n          budget\n      end\n\n    budget.id\n  end\n\n  def format_currency(decimal) do\n    negative? = Decimal.negative?(decimal)\n\n    string =\n      decimal\n      |> Decimal.abs()\n      |> Decimal.round(2)\n      |> Decimal.to_string()\n\n    currency = if negative?, do: \"-$\", else: \"$\"\n\n    formatted_dollars =\n      string\n      |> String.slice(0..-4)\n      |> String.reverse()\n      |> String.codepoints()\n      |> Enum.chunk_every(3)\n      |> Enum.join(\",\")\n      |> String.reverse()\n\n    decimals = String.slice(string, -3..-1)\n\n    currency <> formatted_dollars <> decimals\n  end\nend","coverage":[null,null,null,null,null,null,9,9,null,null,null,null,null,null,null,null,null,null,null,2,null,null,7,null,null,9,null,null,null,21,null,21,null,null,null,null,null,21,null,21,null,null,null,null,null,null,null,null,21,null,21,null,null]},{"name":"lib/spendable/resources/user/calculations/plaid_link_token.ex","source":"defmodule Spendable.User.Calculations.PlaidLinkToken do\n  use Ash.Calculation, type: :string\n\n  import Ecto.Query\n\n  alias Spendable.BankMember\n  alias Spendable.Repo\n\n  @impl Ash.Calculation\n  def calculate([user], _opts, _resolution) do\n    count = from(BankMember, where: [user_id: ^user.id]) |> Repo.aggregate(:count, :id)\n\n    if count < user.bank_limit do\n      with {:ok, %{body: %{\"link_token\" => token}}} <- Plaid.create_link_token(user.id) do\n        {:ok, [token]}\n      end\n    else\n      {:error, [:no_connections_available]}\n    end\n  end\n\n  def calculate([], _opts, _resolution), do: {:ok, []}\nend","coverage":[null,null,null,null,null,null,null,null,null,null,2,null,2,1,null,null,null,null,null,null,null,0,null]},{"name":"lib/spendable_web.ex","source":"defmodule SpendableWeb do\n  @moduledoc \"\"\"\n  The entrypoint for defining your web interface, such\n  as controllers, components, channels, and so on.\n\n  This can be used in your application as:\n\n      use SpendableWeb, :controller\n      use SpendableWeb, :html\n\n  The definitions below will be executed for every controller,\n  component, etc, so keep them short and clean, focused\n  on imports, uses and aliases.\n\n  Do NOT define functions inside the quoted expressions\n  below. Instead, define additional modules and import\n  those modules here.\n  \"\"\"\n\n  def static_paths(), do: ~w(assets fonts images favicon.svg mask-icon.svg robots.txt)\n\n  def router() do\n    quote do\n      use Phoenix.Router, helpers: false\n\n      # Import common connection and controller functions to use in pipelines\n      import Plug.Conn\n      import Phoenix.Controller\n      import Phoenix.LiveView.Router\n    end\n  end\n\n  def channel() do\n    quote do\n      use Phoenix.Channel\n    end\n  end\n\n  def controller() do\n    quote do\n      use Phoenix.Controller,\n        formats: [:html, :json],\n        layouts: [html: SpendableWeb.Layouts]\n\n      import Plug.Conn\n      import SpendableWeb.Gettext\n\n      unquote(verified_routes())\n    end\n  end\n\n  def live_view() do\n    quote do\n      use Phoenix.LiveView,\n        layout: {SpendableWeb.Layouts, :app}\n\n      unquote(html_helpers())\n    end\n  end\n\n  def live_component() do\n    quote do\n      use Phoenix.LiveComponent\n\n      unquote(html_helpers())\n    end\n  end\n\n  def html() do\n    quote do\n      use Phoenix.Component\n\n      # Import convenience functions from controllers\n      import Phoenix.Controller,\n        only: [get_csrf_token: 0, view_module: 1, view_template: 1]\n\n      # Include general helpers for rendering HTML\n      unquote(html_helpers())\n    end\n  end\n\n  defp html_helpers() do\n    quote do\n      # HTML escaping functionality\n      import Phoenix.HTML\n      # Core UI components and translation\n      import SpendableWeb.CoreComponents\n      import SpendableWeb.Gettext\n\n      # Shortcut for generating JS commands\n      alias Phoenix.LiveView.JS\n\n      # Routes generation with the ~p sigil\n      unquote(verified_routes())\n    end\n  end\n\n  def verified_routes() do\n    quote do\n      use Phoenix.VerifiedRoutes,\n        endpoint: SpendableWeb.Endpoint,\n        router: SpendableWeb.Router,\n        statics: SpendableWeb.static_paths()\n    end\n  end\n\n  @doc \"\"\"\n  When used, dispatch to the appropriate controller/view/etc.\n  \"\"\"\n  defmacro __using__(which) when is_atom(which) do\n    apply(__MODULE__, which, [])\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,5,null,null]},{"name":"lib/spendable/broadway/sync_member/sync_member.ex","source":"defmodule Spendable.Broadway.SyncMember do\n  use Broadway\n\n  import Ecto.Query\n\n  alias Broadway.Message\n  alias Spendable.Api\n  alias Spendable.BankAccount\n  alias Spendable.BankMember\n  alias Spendable.BankTransaction\n  alias Spendable.Plaid.Adapter\n  alias Spendable.Repo\n  alias Spendable.Transaction\n\n  require Application\n  require Ash.Query\n\n  @producer if Application.compile_env(:spendable, :env) == :prod,\n              do:\n                {BroadwayCloudPubSub.Producer,\n                 subscription: \"projects/cloud-57/subscriptions/spendable.sync-member-request\"},\n              else: {Broadway.DummyProducer, []}\n\n  def start_link(opts) do\n    Broadway.start_link(__MODULE__,\n      name: opts[:name] || __MODULE__,\n      producer: [\n        module: @producer\n      ],\n      processors: [\n        default: []\n      ],\n      batchers: [\n        default: [\n          batch_size: 10,\n          batch_timeout: 2_000\n        ]\n      ]\n    )\n  end\n\n  def handle_message(_processor_name, message, _context) do\n    Message.update_data(message, &process_data/1)\n  end\n\n  def handle_batch(_batch_name, messages, _batch_info, _context) do\n    messages\n  end\n\n  defp process_data(data) do\n    %Banks.V1.SyncMemberRequest{member_id: member_id} = Banks.V1.SyncMemberRequest.decode(data)\n\n    BankMember\n    |> Api.get(member_id, load: [:user])\n    |> sync_member()\n    |> sync_accounts()\n    |> Enum.filter(& &1.sync)\n    |> Enum.each(&sync_transactions/1)\n  end\n\n  defp sync_member({:ok, member}) do\n    {:ok, %{body: details}} = Plaid.item(member.plaid_token)\n\n    formatted_data = Adapter.bank_member(details)\n\n    member\n    |> Ash.Changeset.for_update(:update)\n    |> Ash.Changeset.force_change_attributes(formatted_data)\n    |> Api.update!()\n  end\n\n  defp sync_member(_result), do: :ok\n\n  def sync_accounts(member) do\n    case Plaid.accounts(member.plaid_token) do\n      {:ok, %{body: %{\"accounts\" => accounts_details}}} ->\n        Enum.map(accounts_details, fn account_details ->\n          formatted_data = Adapter.bank_account(account_details)\n\n          Api.get(BankAccount,\n            user_id: member.user.id,\n            external_id: account_details[\"account_id\"]\n          )\n          |> case do\n            {:error, %Ash.Error.Invalid{errors: [%Ash.Error.Query.NotFound{}]}} ->\n              BankAccount\n              |> Ash.Changeset.for_create(:create, formatted_data)\n              |> Ash.Changeset.force_change_attributes(formatted_data)\n              |> Ash.Changeset.manage_relationship(:bank_member, member, type: :append_and_remove)\n              |> Ash.Changeset.manage_relationship(:user, member.user, type: :append_and_remove)\n              |> Api.create!()\n\n            {:ok, bank_account} ->\n              bank_account\n              |> Ash.Changeset.for_update(:update)\n              |> Ash.Changeset.force_change_attributes(formatted_data)\n              |> Ash.Changeset.manage_relationship(:bank_member, member, type: :append_and_remove)\n              |> Ash.Changeset.manage_relationship(:user, member.user, type: :append_and_remove)\n              |> Api.update!()\n          end\n        end)\n\n      {:ok, %{body: %{\"error_code\" => \"ITEM_LOGIN_REQUIRED\"}}} ->\n        []\n    end\n  end\n\n  defp sync_transactions(account, opts \\\\ []) do\n    count = opts[:count] || 500\n    offset = opts[:offset] || 0\n    cursor = offset + count\n\n    case Plaid.account_transactions(account.bank_member.plaid_token, account.external_id, opts) do\n      {:ok, %{body: %{\"transactions\" => transactions_details} = response}} ->\n        Enum.each(transactions_details, fn transaction_details ->\n          sync_transaction(transaction_details, account)\n        end)\n\n        with %{\"total_transactions\" => total} when total > cursor <- response do\n          sync_transactions(account, Keyword.merge(opts, offset: cursor))\n        end\n\n      {:ok, %{body: %{\"error_code\" => \"PRODUCT_NOT_READY\"}}} ->\n        :ok\n    end\n  end\n\n  defp sync_transaction(details, account) do\n    Repo.transaction(fn ->\n      formatted_bank_transaction_data = Adapter.bank_transaction(details)\n\n      BankTransaction\n      |> Ash.Changeset.for_create(:create, formatted_bank_transaction_data)\n      |> Ash.Changeset.manage_relationship(:bank_account, account, type: :append_and_remove)\n      |> Ash.Changeset.manage_relationship(:user, account.user, type: :append_and_remove)\n      |> Ash.Changeset.force_change_attributes(formatted_bank_transaction_data)\n      |> Api.create()\n      |> case do\n        {:ok, bank_transaction} ->\n          formatted_transaction_data = Adapter.transaction(bank_transaction)\n\n          Transaction\n          |> Ash.Changeset.for_create(:create, formatted_transaction_data, actor: account.user)\n          |> Ash.Changeset.manage_relationship(:bank_transaction, bank_transaction, type: :append_and_remove)\n          |> Ash.Changeset.manage_relationship(:user, account.user, type: :append_and_remove)\n          |> Api.create!()\n          |> reassign_pending(details)\n\n        error ->\n          Repo.rollback(error)\n      end\n    end)\n  end\n\n  defp reassign_pending(transaction, %{\"pending_transaction_id\" => pending_id})\n       when is_binary(pending_id) do\n    BankTransaction\n    |> Ash.Query.filter(external_id: pending_id, pending: true)\n    |> Ash.Query.load(:transaction)\n    |> Api.read_one()\n    |> case do\n      {:ok, %{transaction: %{id: pending_transasction_id}} = pending_bank_transaction} ->\n        from(Spendable.BudgetAllocation, where: [transaction_id: ^pending_transasction_id])\n        |> Repo.update_all(set: [transaction_id: transaction.id])\n\n        Repo.delete!(pending_bank_transaction.transaction)\n        Repo.delete!(pending_bank_transaction)\n\n        transaction\n\n      _not_found_or_bank_transaction ->\n        transaction\n    end\n  end\n\n  defp reassign_pending(transaction, _details), do: transaction\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,2,null,null,null,2,null,null,null,null,null,16,2,null,null,null,2,null,2,null,null,null,null,2,null,null,0,null,null,2,null,2,16,null,null,16,null,null,16,null,null,null,null,null,8,8,null,null,null,null,null,null,8,8,null,null,null,0,null,null,null,null,null,1,1,1,null,1,null,1,8,null,null,1,0,null,null,0,null,null,null,null,null,8,8,null,null,null,null,8,null,null,8,null,8,null,null,8,null,8,null,8,null,null,0,null,null,null,null,null,null,null,null,null,null,1,null,null,1,null,1,1,null,1,null,null,0,null,null,null,7,null]},{"name":"lib/spendable/api.ex","source":"defmodule Spendable.Api do\n  use Ash.Api\n\n  resources do\n    registry Spendable.Registry\n  end\nend","coverage":[null,null,null,null,null,null,null]},{"name":"lib/spendable_web/gettext.ex","source":"defmodule SpendableWeb.Gettext do\n  @moduledoc \"\"\"\n  A module providing Internationalization with a gettext-based API.\n\n  By using [Gettext](https://hexdocs.pm/gettext),\n  your module gains a set of macros for translations, for example:\n\n      import SpendableWeb.Gettext\n\n      # Simple translation\n      gettext(\"Here is the string to translate\")\n\n      # Plural translation\n      ngettext(\"Here is the string to translate\",\n               \"Here are the strings to translate\",\n               3)\n\n      # Domain-based translation\n      dgettext(\"errors\", \"Here is the error message to translate\")\n\n  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.\n  \"\"\"\n  use Gettext, otp_app: :spendable\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"lib/spendable_web/controllers/plaid_controller.ex","source":"defmodule SpendableWeb.PlaidController do\n  use SpendableWeb, :controller\n\n  alias Spendable.Api\n  alias Spendable.Publishers.SyncMemberRequest\n\n  def webhook(conn, %{\"item_id\" => item_id}) when is_binary(item_id) do\n    case Api.get(Spendable.BankMember, external_id: item_id) do\n      {:ok, bank_member} ->\n        {:ok, %{status: 200}} = SyncMemberRequest.publish(bank_member.id)\n\n        send_resp(conn, :ok, \"\")\n\n      {:error, %Ash.Error.Invalid{errors: [%Ash.Error.Query.NotFound{}]}} ->\n        send_resp(conn, :not_found, \"\")\n    end\n  end\n\n  def webhook(conn, _params), do: send_resp(conn, :not_found, \"\")\nend","coverage":[null,null,null,null,null,null,null,2,null,1,null,1,null,null,1,null,null,null,1,null]},{"name":"lib/spendable/behaviours/tesla.ex","source":"defmodule Spendable.Behaviour.Tesla do\n  @callback call(Tesla.Env.t(), any()) :: Tesla.Env.result()\nend","coverage":[null,null,null]},{"name":"lib/spendable_web/controllers/error_json.ex","source":"defmodule SpendableWeb.ErrorJSON do\n  # If you want to customize a particular status code,\n  # you may add your own clauses, such as:\n  #\n  # def render(\"500.json\", _assigns) do\n  #   %{errors: %{detail: \"Internal Server Error\"}}\n  # end\n\n  # By default, Phoenix returns the status message from\n  # the template name. For example, \"404.json\" becomes\n  # \"Not Found\".\n  def render(template, _assigns) do\n    %{errors: %{detail: Phoenix.Controller.status_message_from_template(template)}}\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,0,null,null]},{"name":"lib/spendable/application.ex","source":"defmodule Spendable.Application do\n  # See https://hexdocs.pm/elixir/Application.html\n  # for more information on OTP Applications\n  @moduledoc false\n\n  use Application\n\n  @impl true\n  def start(_type, _args) do\n    SpandexPhoenix.Telemetry.install()\n\n    :ok =\n      :telemetry.attach(\n        \"spandex-query-tracer\",\n        [:spendable, :repo, :query],\n        &SpandexEcto.TelemetryAdapter.handle_event/4,\n        nil\n      )\n\n    children = [\n      {Finch, name: Spendable.Finch},\n      SpendableWeb.Telemetry,\n      Spendable.Repo,\n      {Phoenix.PubSub, name: Spendable.PubSub},\n      SpendableWeb.Endpoint,\n      Spendable.Broadway.SyncMember\n    ]\n\n    children =\n      if Application.get_env(:spendable, :env) == :prod,\n        do: [SpandexOTLP.Sender, {Goth, name: Spendable.Goth}] ++ children,\n        else: children\n\n    # See https://hexdocs.pm/elixir/Supervisor.html\n    # for other strategies and supported options\n    opts = [strategy: :one_for_one, name: Spendable.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n\n  # Tell Phoenix to update the endpoint configuration\n  # whenever the application is updated.\n  @impl true\n  def config_change(changed, _new, removed) do\n    SpendableWeb.Endpoint.config_change(changed, removed)\n    :ok\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,1,null,1,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,1,null,0,1,null,null,null,1,1,null,null,null,null,null,null,0,null,null,null]},{"name":"lib/spendable/resources/budget_allocation_template/storage.ex","source":"defmodule Spendable.BudgetAllocationTemplate.Storage do\n  alias Spendable.Api\n  alias Spendable.BudgetAllocationTemplate\n\n  require Ash.Query\n\n  def form_options(user_id) do\n    BudgetAllocationTemplate\n    |> Ash.Query.filter(user_id == ^user_id)\n    |> Ash.Query.select([:id, :name])\n    |> Ash.Query.sort([:name])\n    |> Api.read!()\n    |> Enum.map(&{&1.name, &1.id})\n  end\n\n  def get_template(id) do\n    Spendable.Api.get!(BudgetAllocationTemplate, id, load: :budget_allocation_template_lines)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null]},{"name":"lib/spendable/behaviours/pubsub.ex","source":"defmodule Spendable.Behaviour.PubSub do\n  @callback publish(binary(), String.t()) :: Tesla.Env.result()\nend","coverage":[null,null,null]},{"name":"lib/spendable/plaid/adapter.ex","source":"defmodule Spendable.Plaid.Adapter do\n  def bank_member(%{\"item\" => details}) do\n    {:ok,\n     %{\n       body: %{\n         \"institution\" => %{\n           \"name\" => name,\n           \"logo\" => logo\n         }\n       }\n     }} = Plaid.institution(details[\"institution_id\"])\n\n    %{\n      external_id: details[\"item_id\"],\n      institution_id: details[\"institution_id\"],\n      logo: logo,\n      name: name,\n      provider: \"Plaid\",\n      status: details[\"error\"][\"error_code\"] || \"CONNECTED\"\n    }\n  end\n\n  def bank_account(details) do\n    available_balance = Decimal.new(\"#{details[\"balances\"][\"available\"] || 0}\")\n    current_balance = Decimal.new(\"#{details[\"balances\"][\"current\"]}\")\n\n    balance =\n      cond do\n        details[\"type\"] == \"credit\" ->\n          Decimal.mult(current_balance, \"-1\")\n\n        Decimal.eq?(available_balance, \"0\") ->\n          current_balance\n\n        true ->\n          available_balance\n      end\n\n    %{\n      balance: balance,\n      external_id: details[\"account_id\"],\n      name: details[\"official_name\"] || details[\"name\"],\n      number: details[\"mask\"],\n      sub_type: details[\"subtype\"],\n      type: details[\"type\"]\n    }\n  end\n\n  def bank_transaction(details) do\n    %{\n      amount: details[\"amount\"] |> to_string() |> Decimal.new() |> Decimal.negate() |> Decimal.round(2),\n      date: details[\"date\"],\n      external_id: details[\"transaction_id\"],\n      name: details[\"name\"],\n      pending: details[\"pending\"]\n    }\n  end\n\n  def transaction(bank_transaction) do\n    %{\n      amount: bank_transaction.amount,\n      date: bank_transaction.date,\n      name: bank_transaction.name,\n      reviewed: false\n    }\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,2,null,null,null,null,16,16,null,16,null,null,2,null,14,8,null,6,6,null,null,16,null,null,16,null,null,null,null,null,null,null,8,8,null,null,null,null,null,null,null,null,8,8,8,8,null,null,null,null]},{"name":"lib/spendable/resources/bank_member.ex","source":"defmodule Spendable.BankMember do\n  use Ash.Resource,\n    authorizers: [Ash.Policy.Authorizer],\n    data_layer: AshPostgres.DataLayer,\n    notifiers: [Spendable.Notifiers.SyncMember]\n\n  alias Spendable.BankMember.Storage\n\n  postgres do\n    repo(Spendable.Repo)\n    table \"bank_members\"\n\n    custom_indexes do\n      index([\"user_id\"])\n    end\n  end\n\n  identities do\n    identity :external_id, [:external_id]\n  end\n\n  attributes do\n    uuid_primary_key :id\n\n    attribute :external_id, :string, allow_nil?: false\n    attribute :institution_id, :string\n    attribute :logo, :string\n    attribute :name, :ci_string, allow_nil?: false\n    attribute :plaid_token, :string, allow_nil?: false, private?: true\n    attribute :provider, :string, allow_nil?: false\n    attribute :status, :string\n\n    timestamps()\n  end\n\n  relationships do\n    belongs_to :user, Spendable.User, allow_nil?: false\n    has_many :bank_accounts, Spendable.BankAccount, sort: :name\n  end\n\n  calculations do\n    calculate :plaid_link_token, :string, Spendable.BankMember.Calculations.PlaidLinkToken,\n      allow_nil?: false,\n      select: [:user_id, :plaid_token]\n  end\n\n  actions do\n    defaults [:read, :update]\n\n    create :create_from_public_token do\n      argument :public_token, :string, allow_nil?: false\n      accept [:public_token]\n      allow_nil_input [:external_id, :name, :provider]\n      change relate_actor(:user)\n      change Spendable.BankMember.Changes.CreateBankMember\n    end\n\n    create :factory do\n      argument :plaid_token, :string\n      change set_attribute(:plaid_token, arg(:plaid_token))\n    end\n  end\n\n  policies do\n    policy always() do\n      authorize_if action(:create_from_public_token)\n      authorize_if expr(user_id == ^actor(:id))\n    end\n  end\n\n  def list(user_id, opts) do\n    Storage.list(user_id, opts)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null]},{"name":"lib/spendable/resources/budget_allocation/preparations/sort.ex","source":"defmodule Spendable.BudgetAllocation.Preparations.Sort do\n  use Ash.Resource.Preparation\n\n  alias Spendable.Api\n\n  @impl Ash.Resource.Preparation\n  def prepare(query, _opts, _context) do\n    query\n    |> Ash.Query.ensure_selected([:name])\n    |> Ash.Query.after_action(fn _query, results ->\n      sorted_results =\n        results\n        |> Api.load!(:budget)\n        |> Enum.sort(fn a, b ->\n          b.budget.name != \"Spendable\" and\n            (a.budget.name == \"Spendable\" or a.budget.name < b.budget.name)\n        end)\n\n      {:ok, sorted_results}\n    end)\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,0,null,null,null,null,null,null]},{"name":"lib/spendable/resources/budget/storage.ex","source":"defmodule Spendable.Budget.Storage do\n  alias Spendable.Api\n  alias Spendable.Budget\n\n  require Ash.Query\n\n  def form_options(user_id) do\n    Budget\n    |> Ash.Query.filter(user_id == ^user_id)\n    |> Ash.Query.filter(is_nil(archived_at))\n    |> Ash.Query.select([:id, :name])\n    |> Ash.Query.after_action(fn _query, results ->\n      {:ok,\n       Enum.sort(results, fn a, b ->\n         to_string(b.name) != \"Spendable\" and\n           (to_string(a.name) == \"Spendable\" or a.name < b.name)\n       end)}\n    end)\n    |> Api.read!()\n    |> Enum.map(&{&1.name, &1.id})\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null,null,null,6,null,null,0,0,null,null,null,6,null,null]},{"name":"lib/spendable/resources/budget/preparations/sort.ex","source":"defmodule Spendable.Budget.Preparations.Sort do\n  use Ash.Resource.Preparation\n\n  @impl Ash.Resource.Preparation\n  def prepare(query, _opts, _context) do\n    query\n    |> Ash.Query.ensure_selected([:name])\n    |> Ash.Query.after_action(fn _query, results ->\n      {:ok,\n       Enum.sort(results, fn a, b ->\n         b.name != \"Spendable\" and (a.name == \"Spendable\" or a.name < b.name)\n       end)}\n    end)\n  end\nend","coverage":[null,null,null,null,null,null,null,0,null,null,0,null,null,null,null]},{"name":"lib/spendable_web/controllers/auth_html.ex","source":"defmodule SpendableWeb.AuthHTML do\n  use SpendableWeb, :html\n\n  embed_templates \"auth_html/*\"\nend","coverage":[null,null,null,null,null]},{"name":"lib/spendable/resources/user/spent_by_month.ex","source":"defmodule Spendable.User.SpentByMonth do\n  use Ash.Resource,\n    data_layer: :embedded\n\n  attributes do\n    attribute :month, :date, allow_nil?: false\n    attribute :spent, :decimal, allow_nil?: false\n  end\nend","coverage":[null,null,null,null,null,null,null,null,null]}]}